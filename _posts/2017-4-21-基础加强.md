---
layout: post
title: 基础加强
tags:
- java

categories: java
description: 基础加强
---
## 代理模式
> Proxy Pattern(代理模式) 代理对象可以再客户端和目标对象之间起到中介的作用
> + 职责清晰
> + 中介作用保护了目标对象的作用
> + 高扩展性
> 结构: 代理对象和目标对象实现同一个接口
###### 静态代理
```
//出租者
public interface Lessor {
    public void hire();
    public void collectRent();
}
//业主
public class Owner implements Lessor{
    public void hire(){
        System.out.println("业主出租房子");
    }
    public void collectRent(){
        System.out.println("收房租");
    }
}
//中介
public class Agent implements Lessor{
    private Lessor ower;
    public Agent(Lessor lessor){
        ower=lessor;
    }

    @Override
    public void hire() {
        System.out.println("挂到网上出租房子");
        ower.hire();
    }

    @Override
    public void collectRent() {
        System.out.println("收取中介费");
        ower.collectRent();
    }
}
//客户
public class Client {
    public static void main(String[] args) {
        Owner owner = new Owner();
        Agent agent = new Agent(owner);
        Lessor proxy= (Lessor) Proxy.newProxyInstance(owner.getClass().getClassLoader(), owner.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                return method.invoke(owner,args);
            }
        });
        proxy.hire();
        proxy.collectRent();
        agent.hire();
        agent.collectRent();
    }
}
```
### 动态代理
> 直接通过反射生成一个代理对象，没有具体的代理类
> Proxy类可以实现，cglib(spring)
```
Proxy动态代理
	|
	|--产生代理类的实例
	|		|
	|		|--Proxy.newProxyInstance(classLoader,interfaces,invocationHandler);
	|
	|--ClassLoader:类加载器，固定写法和被代理类使用相同的即可
	|
	|
	|--Class[]interface:代理类要实现的接口，固定写法，和被代理类使用相同即可
	|
	|
	|--InvocationHandler:策略设计模式的应用
			|
			|--invoke(Object proxy,Method method,Object[]args)
					|
					|--proxy:代理对象本身的引用，一般用不着
					|--method：当前调用的方法
					|--Object[]args:当前方法用的参数

```
### AOP (切面编程)
```
public class ObjectFactory {
    public static AccountService getAccountService(){
        AccountService as=new AccountServiceImpl();
        return (AccountService) Proxy.newProxyInstance(as.getClass().getClassLoader(), as.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Object o=null;
                try {
                    ManagerThreadLocal.startTransacation();
                    o= method.invoke(as, args);
                    ManagerThreadLocal.commit();
                } catch (Exception e) {
                    e.printStackTrace();
                    ManagerThreadLocal.rollback();
                }finally {
                    ManagerThreadLocal.release();
                }

                return o;
            }
        });
    }
}
```
## 注解
> 给程序看的，用于描述程序如何运行以及在什么阶段运行,最大功能用于替换配置文件
> 注解是jdk1.5新特性，可以通过反色让注解具有功能
###### 三个基本注解
+ @Override:检查子类确实是覆盖了父类的方法
+ @Deprecated: 说明已经过时了
+ @Suppress Warnings({"unused","deprecation"}):抑制程序中的警告。unused 警告的类型{}数组，all抑制所有的警告
###### 自定义注解的语法
```
@interface AnnotationName
	|
	|--反编译后:interface AnnotationName extends java.lang.annotation.Annotation
	|
	|--属性格式: int field()
	|		|
	|		|--规定只能包含属性，属性格式为int field() default -1;
	|		|
	|		|--属性类型
	|			 |
	|			 |--基本类型
	|			 |--String
	|			 |--注解类型
	|			 |--Class类型
	|			 |--以上类型的一维数组
	|
	|--创建
	|	|
	|	|--public @interface MyAnnocation {
    |			int age();//属性
    |			String name();
    |		}
	|
	|
	|--使用
		|
		|--  @MyAnnocation(age=18,name = "张三")
    		 public void fun(){}
```
## 注解的反射
> 被注解的元素

## 元注解
> 只能用在注解上的叫做元注解(用于修饰注解的注解)
```
元注解
  |
  |--@Retention作用:改变自定义的注解的存活范围
  |	   |
  |	   |--RetentionPolicy 默认Class级别
  |	   		   |
  |	   		   |--SOURCE  .java
  |	   		   |--Class   .class
  |	   		   |--RUNTIME  内存中
  |
  |
  |--@Target作用:指定该注解能用在什么地方
  |	   |
  |	   |--ElementType
  |	   		   |
  |	   		   |--TYPE	类
  |	   		   |--METHOD 方法
  |	   		   |--FIELD 属性
  |
  |--@Documented 如果注解使用了documented修饰了，那么使用这个注解的类的API文档中会出现这个注解的身影
  |
  |
  |--@Inherited 说明该注解可以被继承下去 如果注解使用了Inherited修饰，那么使用这个注解的类的子类也会有这个注解
```
```
//MyTest
@Documented
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.TYPE})
public @interface MyTest {
    long timeout() default Long.MAX_VALUE;
}

//SomeDaoImpl
public class SomeDaoImpl {
    @MyTest(timeout = 1000)
    public void testAdd(){
        System.out.println("add方法执行");
    }
    @MyTest
    public void testUpdate(){
        System.out.println("update方法执行了");
    }
}

//TestRunner
public static void main(String[] args) throws Exception {
    //test1();
    Class clazz=SomeDaoImpl.class;
    SomeDaoImpl s= (SomeDaoImpl) clazz.newInstance();
    Method[] methods = clazz.getMethods();
    for(Method m:methods){
        MyTest myTest = m.getAnnotation(MyTest.class);
        if(myTest!=null){
            long timeout = myTest.timeout();
            long start = System.nanoTime();
            m.invoke(s,null);
            long end = System.nanoTime();
            long duration = end - start;
            if(duration>timeout){
                System.out.println("执行时间"+duration+"纳秒，超时");
            }else {
                System.out.println("执行时间"+duration+"纳秒，没有超时");
            }
        }
    }
}
```
## Servlet3.0注解
|类型|优点|缺点|
|-----|-----|-----|
|web.xml|可配置，不用改源码|不直观，开发效率低|
|注解|直观，开发效率高|硬编码|
```
servlet3.0注解
	|
	|--@WebServlet 相当于在web.xml中配置Servlet
	|		|
	|		|--String name() servlet名字
	|		|
	|		|--String[] value() 访问地址 value是可以直接赋值 @WebServlet("/servlet/demo1")
	|		|
	|		|--String[] urlPatterns() 访问地址
	|		|
	|		|--WebInitParam[] initParams() 初始化参数
	|
	|
	|
	|--@WebFilter 相当于在web.xml中配置Servetl
	|		|
	|		|--value()和urlPatterns() 过滤地址
	|
	|
	|--@WebListener
```

## 类加载器
> 类加载器负责将.class文件加载到内存中，并为之生成对象的java.lang.Class对象
> 当jvm启动时，会形成由三个类加载器组成的初始类加载器层次结构
```
BootStrap引导类加载器，底层是c JRE/lib/rt.jar
	|
	|
	|--ExtClassLoader扩展类加载器 JRE/lib/ext/*.jar
	|		|
	|		|
	|		|--AppClassLoader系统类加载器 CLASSPATH指定的所有jar或目录(lib)
	|		|		|
	|		|		|
	|		|		|--MyClassLoader自定义类加载器 自己指定的特殊目录
	|


父类委托机制:避免重复加载
	 ↓
AppClassLoader
	 |
	 |--委托父类查找
	 ↓							 
ExtClassLoader
	 |
	 |--委托父类查找
	 ↓		
BootStrap	→ 找到:结束查找 ↗
	 |
	 |--没有找到:子类去找		
	 ↓
ExtClassLoader	→ 找到:结束查找 ↗
	 |
	 |--没有找到:子类去找
	 ↓
AppClassLoader	→  找到:结束查找 ↗
	 |
	 |--没有找到
	 ↓
ClassNotFoundException		
```
```
class A extends B{}
会先找A
AppClassLoader
     |  
     |--委托父类查找  
     ↓                           
ExtClassLoader
     |
     |--委托父类查找  
     ↓      
BootStrap   
     |
     |--没有找到:子类去找       
     ↓  
ExtClassLoader  → 找到A
					|
					|--再找B
					    |
     					|--委托父类查找  
     					↓   
     				BootStrap  → 找到B,返回
     					|
    					|--没有找到:子类去找       
     					↓   
     				ExtClassLoader → 找到B,返回
     				     |  
     					 |--没有找到
     					 ↓
     		不会向下再找，抛出classNotFoundException	    
```
```
public static void main(String[] args) {
    ClassLoader bootStrup = Class.class.getClassLoader();
    System.out.println(bootStrup);//bootstrup底层是c
    ClassLoader extClassLoader = DNSNameService.class.getClassLoader();
    System.out.println(extClassLoader);
    ClassLoader appClassLoader = AccountDao.class.getClassLoader();
    System.out.println(appClassLoader);
    ClassLoader appClassLoader2 = TestClassLoader.class.getClassLoader();
    System.out.println(appClassLoader2);
    /**打印结果
    null
    sun.misc.Launcher$ExtClassLoader@6ff3c5b5
    sun.misc.Launcher$AppClassLoader@14dad5dc
    sun.misc.Launcher$AppClassLoader@14dad5dc
    **/
}
```

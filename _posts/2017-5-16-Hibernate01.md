---
layout: post
title: Hibernate配置和api
tags:
- java

categories: java
description:Hibernate配置和api
---
## hibernate
> Hibernate是一个数据持久化层的ORM框架.(持久化把数据保存到数据库或者硬盘 orm 对象关系映射)
> orm元数据:配置文件
###### 步骤
```
Hibernate3.6.10使用步骤
	|
	|--添加jar包
	|	  |
	|	  |--mysql-connector-xx.jar  mysql驱动
	|	  |--Hibernate3.6.10目录
	|	  		|  	
	|	  		|--hibernate3.jar 核心
	|	 	    |--lib目录
	|	 	    	 |--required目录所有jar
	|				 |		|--antlr-xxx.jar 解析框架，hibernate用于解析HQL
	|				 |		|--commons-collections-xx.jar  集合增强包
	|				 |		|--dom4j-xxx.jar 解析xml
	|				 |		|--javassist-xxx.jar 字节码增强(代理)
	|				 |      |--jta-xx.jar java transaction api 事务规范
	|				 |		|--slf4j-api-xx.jar 日志框架(整合log4j)
	|				 |		
	|				 |--jpa目录jar
	|						|--hibernate-jpa-xx.jar  jap规范支持
	|
	|--添加配置文件
		  |
		  |--编写核心配置文件
		  |		|--hibernate.cfg.xml复制到src目录下，修改配置
		  |				|--hibernate.cfg.xml
		  |					|
		  |					|--Hibernate3.6.10目录
		  |					 		|--project
		  |					 			 |--etc 里面			
		  |										
		  |
		  |--编写JavaBean+映射配置
		  |			|
		  |			|--格式:JavaBean名称.hbm.xml
		  |						|
		  |						|--DTD位置
		  |							|--hibernate3.jar包名路径下
		  |
		  |--映射添加到核心配置文件
```
###### 示例
```
//hibernate.cfg.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-configuration PUBLIC
   "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
   "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
   <session-factory >
      <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
      <property name="hibernate.connection.username">root</property>
      <property name="hibernate.connection.password">root</property>
      <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/ee19day01?characterEncoding=utf-8</property>
      <!--操作数据库会向控制台打印sql语句-->
      <property name="show_sql">true</property>
      <!--打印sql前,会讲sql格式化-->
      <property name="format_sql">true</property>
      <!--hdm2ddl.auto:是否自动生成表结构-->
      <property name="hbm2ddl.auto">update</property>
      <property name="hibernate.connection.autocommit">true</property>
      <mapping resource="com/itheima/a_hello/User.hbm.xml"/>
   </session-factory>
</hibernate-configuration>

//User.java
public class User {
    private int id;
    private String name;
    private String password;
}


//User.hbm.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="com.itheima.a_hello.User" table="t_user">
        <id name="id" column="id">
            <generator class="native"></generator>
        </id>
        <property name="name" column="name"></property>
        <property name="password" column="password"></property>
    </class>
</hibernate-mapping>

public class Test01 {
    @Test
    public void fun1(){
        //1.读取配置文件
        Configuration conf=new Configuration().configure();
        //2.根据配置创建Factory
        SessionFactory factory=conf.buildSessionFactory();
        //3.通过获得操作数据的session对象
        Session session = factory.openSession();
        //4.操作数据库
        User u=new User();
        u.setName("张三");
        u.setPassword("1234");
        session.save(u);
        //5.关闭资源
        session.close();
        factory.close();
    }
}
```
## api
>      1 load方法.返回一个代理对象,获得其内容时,会查询数据库,是每次访问属性都会查询数据库吗?
	答:不是每次都查.代理对象中有一个标识是否被初始化的boolean型变量. 记录是否被初始化过.
	2 代理都是要基于接口的,用load方法返回的代理,就没有实现任何接口?
	答: java中的动态代理是基于接口.  而 Hibernate 是使用javassist-3.12.0.GA.jar 产生代理对象的.
	该代理与被代理对象之间的关系是继承关系.与我们学的动态代理不是一种.所以不需要接口.
|方法|备注|
|------|-----|
| conf=new Configuration().configure()|加载配置文件|
|new Configuration().configure(file)|加载指定位置配置文件|
|new Configuration().configure(path)|加载指定位置配置文件|
|conf.addClass(User.class)|加载映射文件(不推荐)推荐使用hibernate.cfg.xml mapping属性引入配置文件|
|ORM文件规范|1.orm映射文件名与实体的简单名一致,2.orm映射文件和实体类同路径|
|conf.buildSessionFactory()|创建SessionFactory|
|factory.openSession()|获得全新的session|
|factory.getCurrentSession()|获得与当前线程绑定的session(ThreadLocal)|
|session.save(obj)|保存对象到数据库|
|session.get(obj.class, 1)|通过主键id查找对象|
|session.update(user)|修改对象|
|session.delete(obj)|删除对象，根据对象id删除|
|session.load(obj.class, 2)|通过主键id查找对象,反射代理延迟加载|
|session.createSQLQuery(sql)|sql语句操作|
|uery.addEntity(User.class)|指定结果封装成实体|
|session.beginTransaction()|打开事务|
|transaction.commit()|提交事务|
|transaction.rollback()|回滚事务|
|session.getTransation()|得到已经打开的事务|
|session.createQuery("from 全类名称")|获得query对象|
|query.list()|查询所有|
|query.uniqueResult()|取一个结果|
|query.setFirstResult(2)|从第几个结果取|
|query.setMaxResults(3)|取几个结果|
|session.createCriteria(obj.class)|获得criteria对象|
|criteria.list()|查询所有|
|criteria.uniqueResult()|查询单个结果|
|criteria.setFirstResult(3)|从第几个开始取|
|criteria.setMaxResults(2)|设置查询多少个|
|criteria.add(Restrictions)|添加查询条件|
```
public class Configuration_test {
    @Test
    public void fun1(){
        Configuration conf=new Configuration().configure();
//        Configuration conf=new Configuration().configure(file);
//        Configuration conf=new Configuration().configure(path);
        //加载映射文件(不推荐)
        //推荐使用hibernate.cfg.xml mapping属性引入配置文件
        //规范orm文件 1.orm映射文件名与实体的简单名一致
        // 2.orm映射文件和实体类同路径

        conf.addClass(User.class);
    }
}

//SeesionFactory
public class SessionFactory_test {
    @Test
    public void fun1(){
        Configuration conf=new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        factory.openSession();
        factory.getCurrentSession();
    }
}

//Session
public class Session_test {
    @Test
    public void fun1() {
        //添加
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        User user = new User();
        user.setName("景甜");
        user.setPassword("1234");
        session.save(user);
        session.close();
        factory.close();
    }

    @Test
    public void fun2() {
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        User user = (User) session.get(User.class, 1);
        System.out.println(user);
        user.setName("刘亦菲");
        session.update(user);
        ts.commit();

    }
    @Test
    public void fun3(){
        //删除
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        User user = (User) session.get(User.class, 1);
        session.delete(user);
        ts.commit();
        session.close();
        factory.close();
    }
    @Test
    public void fun4(){
        //查询
        //get: get方法被调用时立刻发送sql语句
        //load: 调用并没有查询数据库，当我们需要使用该对象的时候 查询对象
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        User user = (User) session.load(User.class, 2);
        System.out.println(user);
        ts.commit();
        session.close();
        factory.close();
    }
    @Test
    public void fun5(){
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from com.itheima.a_hello.User");//传入hql语句
        List<User> list = query.list();
        System.out.println(list);
        ts.commit();
    }
    @Test
    public void fun6(){
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        Criteria criteria = session.createCriteria(User.class);
        List<User> list = criteria.list();
        System.out.println(list);
        ts.commit();
    }
    @Test
    public void fun7(){
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        SQLQuery query = session.createSQLQuery("select * from t_user");
        query.addEntity(User.class);
        List<User> list = query.list();
        System.out.println(list);
        ts.commit();
    }

}

//Query
public class Query_test {
    @Test
    public void fun1(){
        Configuration config = new Configuration().configure();
        SessionFactory factory = config.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        //Query对象 封装HQL语句的对象 封装查询细节的方法
        Query query = session.createQuery("from com.itheima.a_hello.User");
        query.setFirstResult(2);
        query.setMaxResults(3);
        List<User> list = query.list();
        User u  = (User) query.uniqueResult();
        System.out.println(u);
        ts.commit();
    }
}

//Cretiraira
public class Cretiraira_test {
    @Test
    public void fun1(){
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.openSession();
        Transaction ts = session.beginTransaction();
        Criteria criteria = session.createCriteria(User.class);
        criteria.setFirstResult(0);
        criteria.setMaxResults(2);
        List list = criteria.list();
        System.out.println(list);
        criteria=criteria.add(Restrictions.like("name","%周芷若%"));
        User user = (User) criteria.uniqueResult();
        System.out.println(user);
        ts.commit();
    }
}

//Transaction
public class Transaction_test {
    //封装了事务
    @Test
    public void fun1(){
        Configuration conf = new Configuration().configure();
        SessionFactory factory = conf.buildSessionFactory();
        Session session = factory.getCurrentSession();
        Transaction ts = session.beginTransaction();
        ts.commit();
        Session session2 = factory.getCurrentSession();
        System.out.println(session==session2);

        //事务关闭时，会自动把当前线程关联的session关闭，并删除

        //ts.rollback();
        //session.close();
        factory.close();
    }
}
```

###### HibernateUtils
```
public class HibernateUtils {
    private static SessionFactory factory;
    static {
        Configuration conf=new Configuration().configure();
        factory=conf.buildSessionFactory();
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            @Override
            public void run() {
                factory.close();
                System.out.println("虚拟机关闭 释放资源");
            }
        }));
    }
    public static Session openSession(){
        return factory.openSession();
    }
    public static Session getCurrentSession(){
        return factory.getCurrentSession();
    }

    public static void main(String[] args) {
        System.out.println(openSession());
    }
}
```

## hbm2ddl.auto
> 是否自动生成表结构策略

update:
1. 如果当前数据库中不存在表结构 自动创建表结构
1. 如果存在表结构，并且表结构与实体一致，那么不在修改
1. 如果存在表结构，并且表结构与实体不一致，那么修改表结构，并保留原有字段

create:
1. 无论是否存在表结构，每次启动Hibernate都会重新创建表结构(数据会丢失)

create-drop:
1.无论是否存在表结构，每次启动Hibernate都会重新创建表结构，每次Hibernate结束摧毁表

validate:
1. 不会自动创建表结构
2. 也不会自动维护表结构
3. 只负责校验表结构
4. 如果表结构不一致抛异常

## hibernate.dialect
> 数据库方言配置
> mysql 选择org.hibernate.dialect.MySQLDialect

## Hibernate 中持久类
* 提供一个无參public访问的构造方法
* 提供一个表示属性，映射数据库主键
* 所有属性提供pulbic访问控制符的 set get方法
* 标识属性尽量使用基本数据类型的包装类型
* 不要用final修饰类（将无法生成代理对象进行优化）

#### 持久化对象的唯一标识 OID
* Java按地址区分同一个的类的不同对象
* 关系数据库主键区分同一条记录
* Hibernate使用OID来建立内存中的对象和数据库中的记录的对应关系，应该让Hibernate来个OID赋值

#### 区分自然主键和代理主键
> 主键需要具备:不能为空/不能重复/不能改变

1. 自然主键: 在业务中，某个属性符合主键的三个要求，那么该属性可以做为主键列
2. 代理主键: 在业务中,不存在符合以上3个条件的属性。那么就添加一个没有意义的列，作为主键

## Bean.hbm.xml
```
hibernate-mapping标签
	  |		|
	  |		|--package属性
	  |			|--指定包名，class里面可以使用简单类名
	  |
	  |--class标签(配置与表的关系)
	  	   |		|
	  	   |		|--name:实体类完整名称
	  	   |		|--table:与实体类对应表的名称
	  	   |		|--dynamic-insert 动态插入 默认值是false true 如果字段为null 不参与insert
	  	   |		|--dynamic-update:动态更新 true:没有改动的字段 不参与update
	  	   |
	  	   |--id标签(配置主键)
	  	   |		|	|
	  	   |		|	|--name:实体类属性名
	  	   |		|	|--column：主键在表中的名称
	  	   |		|	|--length: 列的长度
	  	   |		|	|--unsaved-value(很少用):指定主键为什么值时当做空处理
	  	   |		|	|--access(强烈推荐不要用):field 通过反射找到字段，赋值。绕过get set
	  	   |		|
	  	   |		|--generator标签(主键生成策略)
	  	   |			 |
	  	   |			 |--increment:数据库自己生成主键，先查询最大主键id值，然后id值+1
	  	   |			 |--identity:依赖数据的主键自增功能
	  	   |			 |--sequence:序列，依赖于数据库中的序列功能(Oracle)
	  	   |			 |--hilo:Hibernate自己实现序列的算法(纯了解，永远用不到)
	  	   |			 |--native:自动根据数据库increment,sequence,hilo三选一
	  	   |			 |--uuid:自动生成32位不重复的字符串
	  	   |			 |--assigned:自己指定主键值，表的主键是自然主键时
	  	   |
	  	   |--property标签(实体中属性和表中列的对应)
	  	   			|
	  	   			|--name:实体属性名称
	  	   			|--column:表中列的名称
	  	   			|--length:数据长度
	  	   			|--scale:小数有效位数
	  	   			|--precision:小数点后面长度
	  	   			|--not-null:指定属性的约束是否使用非空
	  	   			|--unique:指定属性的约束是否唯一
	  	   			|--insert(一般不用):该属性是否加入insert语句，插入的不用该属性
	  	   			|--update(一般不用):update的时候不会管该属性
	  	   			|--type:表达该属性的类型
	  	   				  |
	  	   				  |--java类型 java.lang.String
	  	   				  |--数据库类型指定 varchar
	  	   				  |--Hibernate类型指定 string
```

##### User.hbm.xml
```
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.itheima.a_hello">
    <!--
    class:配置与表的关系
    name:实体类完整名称
    table:与实体类对应表的名称
    dynamic-insert 动态插入 默认值是false true 如果字段为null 不参与insert
    dynamic-update:动态更新 true:没有改动的字段 不参与update
    -->
    <class name="User" table="t_user" dynamic-insert="true" dynamic-update="true">
        <!--
        id:配置主键
        column：主键在表中的名称
        length: 列的长度
        unsaved-value(很少用):指定主键为什么值时当做空处理
        access(强烈推荐不要用):field 通过反射找到字段，赋值。绕过get set
        -->
        <id name="id" column="id" length="9" unsaved-value="0">
            <!--
            主键生成策略
            1.increment:数据库自己生成主键，先查询最大主键id值，然后id值+1
            2.identity:依赖数据的主键自增功能
            3.sequence:序列，依赖于数据库中的序列功能(Oracle)
            4.hilo:Hibernate自己实现序列的算法(纯了解，永远用不到)
            5.native:自动根据数据库increment,sequence,hilo三选一
            6.uuid:自动生成32位不重复的字符串
            7.assigned:自己指定主键值，表的主键是自然主键时
            -->
            <generator class="increment"></generator>
        </id>
        <!--
        name:实体属性名称
        column:表中列的名称
        length:数据长度
        scale:小数有效位数
        precision:小数点后面长度
        insert(一般不用):该属性是否加入insert语句，插入的不用该属性
        not-null:指定属性的约束是否使用非空
        unique:指定属性的约束是否唯一
        update(一般不用):update的时候不会管该属性
        type:表达该属性的类型
        java类型 java.lang.String
        数据库类型指定 varchar
        Hibernate类型指定 string
        -->
        <property name="name" column="name" insert="true" not-null="true" unique="true" update="true" type="java.lang.String"></property>
        <property name="password" column="password"></property>
        <property name="sal" column="sal" precision="2" scale="3"></property>
    </class>
</hibernate-mapping>
```

---
layout: post
title: 线程
tags:
- java

categories: java
description:
---


## 多线程的引入
线程是程序执行的一条路径, 一个进程中可以包含多条线程
多线程并发执行可以提高程序的效率, 可以同时完成多项工作


##多线程并行和并发的区别
并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)
并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。


## Java程序运行原理和JVM的启动是多线程的吗
 Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。
JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。
###### jvm是多线程的
```java
public static void main(String[] args) {
    for(int i=0;i<590000;i++){
        new Demo();
    }
    for(int i=0;i<100;i++){
        System.out.println("如果交叉打印 说明是多线程的");
    }
}
public static class Demo{
    @Override
    protected void finalize() throws Throwable {
        System.out.println("我被回收了");
    }
}
```

## 多线程_继承Thread
开启新线程, 内部会自动执行run方法
```java
public static void main(String[] args) {
    MyThread mt=new MyThread();
    mt.start();
    for(int i=0;i<1000;i++){
        System.out.println("aa");
    }
}
static class MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println("bb");
        }
    }
}
```


## 多线程_实现Runnable
run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法
```java
public static void main(String[] args) {
    Thread t=new Thread(new MyRunnable());
    t.start();
    for(int i=0;i<1000;i++){
        System.out.println("aa");
    }
}
public static class MyRunnable implements Runnable{
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println("bb");
        }
    }
}
```

## 两种方式的区别
实现Runnable接口,即使自己定义的线程类有了父类也没关系
```java
new Thread(){
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println("aa");
        }
    }
}.start();
new Thread(new Runnable() {
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println("bb");
        }
    }
}).start();
```

## 多线程_Method
| 方法 | 备注     |
| :------------- | :------------- |
| new Thread(String name)      | 设置线程名字 |
| getName()       |  获取线程对象的名字 |
| setName(String name)     |  修改线程名字 |
| Thread.currentThread()   |  获取当前线程的对象 |
|Thread.sleep(毫秒)|控制当前线程休眠若干毫秒|
|setDaemon()|设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出|
|join()|当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续|
|Thread.yield()|让出cpu|
|setPriority()|设置线程的优先级|
######  new Thread(String name),getName(),setName(String name)和Thread.currentThread()
```java
new Thread("线程甲"){
    @Override
    public void run() {
        System.out.println("线程名字："+getName());
        setName("线程乙");
        Thread.currentThread().setName("线程丙");
        System.out.println("线程新名字："+Thread.currentThread().getName());
    }
}.start();
```
###### Thread.sleep(毫秒)
```java
new Thread(){
    @Override
    public void run() {
        for(int i=20;i>0;i--){
            System.out.println("倒计时"+i+"秒");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}.start();
```
###### setDaemon()
```java
Thread t1=new Thread("t1"){
    @Override
    public void run() {
        for(int i=0;i<3;i++){
            System.out.println(getName()+" "+i);
            try {
                sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
};
Thread t2=new Thread("t2"){
    @Override
    public void run() {
        for(int i=0;i<50;i++){
            System.out.println(getName()+" "+i);
            try {
                sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
};
t2.setDaemon(true);
t1.start();
t2.start();
```
###### join()
```java
final Thread t1=new Thread("t1"){
    @Override
    public void run() {
        for(int i=0;i<10;i++){
            System.out.println(getName());
            try {
                sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
};
Thread t2=new Thread("t2"){
    @Override
    public void run() {
        for(int i=0;i<10;i++){
            System.out.println(getName());
            try {
                if(i==2){
                    t1.join();//t1.执行完 t2才执行
                }
                sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
};
t1.start();
t2.start();
```
###### Thread.yield()
```java
public static void main(String[] args) {
    new MyThread().start();
    new MyThread().start();
}
public static class MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            if(i%10==0){
                Thread.yield();
            }
            System.out.println(getName()+" "+i);
        }
    }
}
```
###### setPriority
```java
Thread t1=new Thread("t1"){
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println(getName());
        }
    }
};
Thread t2=new Thread("t2"){
    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println(getName());
        }
    }
};
t1.setPriority(Thread.MIN_PRIORITY);
t2.setPriority(Thread.MAX_PRIORITY);
t1.start();
t2.start();
```


## 同步代码块
synchronized(钥匙) 如果钥匙不唯一锁不住
当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.
如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.

###### 四个窗口同时卖票
```java
public static void main(String[] args) {
    new Ticket().start();
    new Ticket().start();
    new Ticket().start();
    new Ticket().start();

}
public static class Ticket extends Thread{
    private static int ticket=100;
    @Override
    public void run() {
        while(true){
            synchronized(Ticket.class) {
                if (ticket > 0) {
                    System.out.println("这是第" + ticket-- + "号票");
                    try {
                        sleep(50);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
```					
## 死锁
多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁
两把锁 2把钥匙才能开门 一人拿了一把钥匙 谁也开不了(一把锁就好，最好不要嵌套)

## 线程安全的类
	Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)
	Vector是线程安全的,ArrayList是线程不安全的
	StringBuffer是线程安全的,StringBuilder是线程不安全的
	Hashtable是线程安全的,HashMap是线程不安全的

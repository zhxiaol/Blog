---
layout: post
title: IO流字节流
tags:
- life

categories: life
description:
---

## IO流
IO流用来处理设备之间的数据传输,Java对数据的操作是通过流的方式,java用于操作流的类都在IO包中,流按流向分为两种：输入流，输出流。,流按操作类型分为两种：字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的,字符流 : 字符流只能操作纯字符数据，比较方便。
使用前，导入IO包中的类。使用时，进行IO异常处理。使用后，释放资源

##### 字节流的抽象父类： InputStream ,OutputStream

##### 字符流的抽象父类： Reader Writer

| 方法     | 备注     |
| :------------- | :------------- |
| int read()       | 返回读取的一个字节，-1结束       |
|int read(byte[] b)| 一次读取一个字节数组，返回读取个数 |
| write(int b)     | 一次写出一个字节|
| write(byte[] b)  | 一次写出一个字节数组 |
|available()       | 获取读的文件所有的字节个数 |
|flush()|刷新缓冲区|
|close|用来关闭流释放资源的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 |

##### 缓冲思想
字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多

##### BufferedInputStream
BufferedInputStream内置了一个缓冲区(数组)
从BufferedInputStream中读取一个字节时
会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个
程序再次读取时, 就不用找文件了, 直接从缓冲区中获取
直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个

##### BufferedOutputStream
BufferedOutputStream也内置了一个缓冲区(数组)
程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中
直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里

##### 小数组的读写和带Buffered的读取哪个更快
定义小数组如果是8192个字节大小和Buffered比较的话
定义小数组会略胜一筹,因为读和写操作的是同一个数组
而Buffered操作的是两个数组

## 练习

###### 标准字节流读写

```java
public static void main(String[] args) throws IOException {
        FileInputStream fis=new FileInputStream("xxx.txt");
        FileOutputStream fos=new FileOutputStream("ccc.txt");
        byte[]arr=new byte[1024*8];
        int len;
        while ((len=fis.read(arr))!=-1){
                fos.write(arr,0,len);
        }
        fis.close();
        fos.close();
    }
```
###### Buffered

```java
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("xxx.txt"));
        BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("eee.txt"));
        int b;
        while((b=bis.read())!=-1){
            bos.write(b);
        }
```

###### jdk1.6之前异常处理

```java
public static void main(String[] args) throws IOException{
       FileInputStream fis=null;
       FileOutputStream fos=null;
       try {
            fis=new FileInputStream("xxx.txt");
            fos=new FileOutputStream("yyy.txt");
           int b;
           while((b=fis.read())!=-1){
               fos.write(b);
           }
       } finally {
           try {
               if(fis!=null)
               fis.close();
           } finally {
               if(fos!=null)
                   fos.close();
           }
       }
   }

```

###### jdk1.7 IO 异常处理
```java
//在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉
public static void main(String[] args)throws IOException {
       try(
               BufferedInputStream bis=new BufferedInputStream(new FileInputStream("xxx.txt"));
               BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("ccc.txt"));
       ){
           int b;
           while((b=bis.read())!=-1){
               bos.write(b);
           }
       }
   }
```

###### 图片加密
```java
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("pass.jpg"));
BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("pass2.jpg"));
  int b;
  while((b=bis.read())!=-1){
        bos.write(b^123);
       }
       bis.close();
       bos.close();
```

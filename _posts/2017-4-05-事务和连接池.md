---
layout: post
title: 事务和连接池
tags:
- java

categories: java
description: 事务和连接池
---
## 事务
> mysql引擎支持事务
> mysql默认自动提交事务。每条语句都处在单独的事务中
> 手动控制事务
+ 开启事务: start transaction | begin
+ 提交事务: commit
+ 回滚事务: rollback
```
try(Connection conn= DBUtils.getConnetion();    
    PreparedStatement ps1=conn.prepareStatement("update account set money =money-100 where name ='aaa'");
    PreparedStatement ps2=conn.prepareStatement("update account set money = money +100 where name ='bbb'");
){
    conn.setAutoCommit(false);
    ps1.executeUpdate();
    int i=1/0;
    ps2.executeUpdate();
    conn.commit();
}catch (SQLException e) {
    e.printStackTrace();
}catch (Exception e){
}
```
## 事务的特性
##### 原子性:
> 要么都成功，要么都失败,不可分割
##### 一致性:
> 事务必须使数据库从一个一致性变换到另一个一致性
##### 隔离性:
> 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务间要隔离
##### 持久性:
>只一个事务一旦提交，它对数据库中的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

## 事务的隔离级别
##### 脏读:
> 指一个事务读取了另一个事务提交前的数据
##### 不可重复读:
> 在一个事务内读取表中某一行的数据，多次读取结果不同(update)
##### 虚读(幻读):
> 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致(insert)

1.READ UNCOMMITTED:脏读、不可重复读、虚读都可能发生。
2.READ COMMITTED:避免脏读。不可重复读、虚读都有可能发生(oracle默认)
4.REPEATABLE READ:避免脏读、不可重复读。虚读有可能发生(mysql默认)
8.SERIALIZABLE:避免脏读、不可重复读、虚读。
级别越高，性能越低，数据月安全
mysql中:
查看当前事务的隔离级别:SELECT @@TX_ISOLATION
更改当前事务的隔离级别:SET TRANSACTION ISOLATION LEVEL 四个级别之一
## 什么是连接池
>数据库连接池负责分配、管理和释放数据库连接，可以提高对数据库操作的性能
## 装饰设计模式
>目的:改写已存在的类个某个方法或某些方法

```
步骤
 |
 |--编写一个类，实现与被包装类相同的接口
 |
 |--定义一个被包装类类型的变量
 |
 |--定义构造方法，把被包装类的对象注入，给包装类变量赋值
 |
 |--对于不需要给的方法，调用原有的方法
 |
 |--对于需要改写的方法，写自己的代码		
```
###### 装饰模式
```
//MyDataSource
public class MyDataSource implements DataSource {
    private static ConcurrentLinkedDeque<Connection> pool= new ConcurrentLinkedDeque<Connection>();
    static {
        try {
            for(int i=0;i<10;i++){
                Connection conn= DBUtils.getConnetion();
                pool.addFirst(conn);
            }
        } catch (SQLException e) {
            throw new ExceptionInInitializerError("初始化数据库连接失败，请检查配置文件");
        }
    }
    @Override
    public Connection getConnection() throws SQLException {
        Connection conn=null;
        if(pool.size()>0){
            conn= pool.removeFirst();
            conn = new MyConnection(conn,pool);
        }else {
            //1.等待2.等待超时新建
            throw new RuntimeException("服务器忙..");
        }
        return conn;
    }
}

//myConnection
public class MyConnection implements Connection {
    private Connection conn;
    private ConcurrentLinkedDeque<Connection> pool;

    public MyConnection(Connection conn, ConcurrentLinkedDeque<Connection> pool) {
        this.conn = conn;
        this.pool = pool;
    }

    @Override
    public void close() throws SQLException {
        System.out.println("放回连接池");
        pool.addLast(conn);
    }

    @Override
    public Statement createStatement() throws SQLException {
        return conn.createStatement();
    }
//...代理所有方法
}
//test
@org.junit.Test
public void test(){
    MyDataSource ds = new MyDataSource();
    try(Connection conn=ds.getConnection();
        PreparedStatement ps=conn.prepareStatement("select * from account");
    ){
        ps.executeQuery();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
```
###### 适配器模式
```
//MyConnection
public class MyConnection extends MyConnectionWarper {
    private Connection conn;
    private ConcurrentLinkedDeque<Connection>pool;

    public MyConnection(Connection conn, Connection conn1, ConcurrentLinkedDeque<Connection> pool) {
        super(conn);
        this.conn = conn1;
        this.pool = pool;
    }

    @Override
    public void close() throws SQLException {
        pool.addLast(conn);
    }
}

//MyConnectionWarper
public class MyConnectionWarper implements Connection {
    private Connection conn;

    public MyConnectionWarper(Connection conn) {
        this.conn = conn;
    }

    @Override
    public Statement createStatement() throws SQLException {
        return conn.createStatement();
    }
//...代理所有方法
}
```

## 常用数据源配置
#### DBCP
>Apache推出的Database Connection Pool
```
使用步骤
   |
   |--添加jar包
   |	 |
   |	 |--commons-dbcp-1.4.jar
   |	 |--commons-pool-1.5.6.jar
   |	 	
   |--添加属性资源文件 dbcpconfig.properties
   |	 |
   |	 |--连接设置(driverClass,url,user,password)
   |	 |--initialSize=10 初始化连接
   |	 |--maxActive=50 最大连接数量
   |	 |--maxIdle=20 最大空闲连接
   |	 |--minIdle=5 最小空闲连接
   |	 |--maxWait=6000 超时等待时间 毫秒
   |     |--connectionProperties=useUnicode=true;characterEncoding=utf8 建立连接附带属性[属性名=property;]
   |	 |--defaultAutoCommit=true 自动提交状态
   |     |--defaultReadOnly 连接的只读状态
   |	 |--defaultTransactionIsolation=REPEATABLE_READ 事务级别			
   |
   |--编写数据库工具类
   		 |
   		 |--static{}静态代码块初始化DataSource ds
   		 |				|
   		 |				|--ropertes.load(DBCPUtil.class.getClassLoader().getResourceAsStream("dbcpconfig.properties"))
   		 |				|--ds=BasicDataSourceFactory.createDataSource(properties)
   		 |
   		 |--getConnection()
   		 |		|
   		 |		|--return ds.getConnection()
   		 |
   		 |--release(ResultSet rs,Statement stmt,Connection conn)
   		 		|
   		 		|--rs.close()
   		 		|--stmt.close()
   		 		|--conn.close()
```
```
public class DBCPUtil {
    private static DataSource ds=null;
    static {
        Properties prop=new Properties();
        try {
            prop.load(DBCPUtil.class.getClassLoader().getResourceAsStream("dbcpconfig.properties"));
            ds= BasicDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
            e.printStackTrace();
            throw new ExceptionInInitializerError("数据库连接池初始化失败,请检查配置文件");
        }
    }
    public static Connection getConnection(){
        try {
            return ds.getConnection();
        } catch (SQLException e) {
            e.printStackTrace();
            throw new RuntimeException("获得数据连接失败");
        }
    }
    public static void release(ResultSet rs,Statement stmt,Connection conn){
        try {
            if(rs!=null)
            rs.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            try {
                if(stmt!=null)
                stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }finally {
                try {
                    if(conn!=null)
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```
#### C3P0
```
使用步骤
   |
   |--添加jar包
   |	 |
   |	 |--c3p0-0.9.1.2.jar
   |	 	
   |--编写配置文件c3p0-config.xml
   |	 |
   |	 |--放在根目录下会自动加载配置
   |	 |--连接设置(driverClass,jdbcUrl,user,password)
   |	 |--initialPoolSize=10 初始化连接
   |	 |--maxIdleTime=30 最大空闲连接
   |	 |--minIdle=5 最小空闲连接
   |	 |--maxPoolSize=100 最大连接池
   |     |--minPoolSize=5	最大连接池
   |
   |--编写数据库工具类
   		 |
   		 |--方式一
   		 |	  |
   		 |	  |--初始化 private static DataSource ds=new ComboPooledDataSource(); 				
   		 |
   		 |--方式二
   		 |	  |
   		 |	  |--初始化 private static ComboPooledDataSource ds=new ComboPooledDataSource();
   		 |	  |
   		 |	  |--{}静态代码块
   		 |			|
   		 |			|--不写xml文件，配置信息写在c3p0-config.properties中
   		 |			|--ResourceBundle.getBundler("c3p0-config")
   		 |			|--ds.setJdbcUrl();
   		 |			|--ds.setUser();
   		 |			|--...
   		 |
   		 |--getConnection()
   		 |		|
   		 |		|--return ds.getConnection()
   		 |
   		 |--release(ResultSet rs,Statement stmt,Connection conn)
   		 		|
   		 		|--rs.close()
   		 		|--stmt.close()
   		 		|--conn.close()
```

## JNDI用JavaWeb服务器管理数据源
> 开发JavaWeb应用,必须使用一个JavaWeb服务器，JavaWeb服务器内置数据源
#### Tomcat:(DBCP)
> 数据源只需配置服务器即可
```
配置数据源步骤
	|
	|--拷贝数据库连接的jar到tomcatlib目录下
	|		|
	|		|--tomcat目录
	|			  |
	|			  |--lib目录
	|					|
	|					|--添加mysql-connection-java-5.0.8-bin.jar		
	|
	|--配置数据源xml文件
	|		|
	|		|--context.xml
	|		|		|
	|		|		|--<Resource name="jdbc/day13" auth="Container" type="java.sql.DataSource"
	|		|		|			 maxActive="100" maxIdle="30" maxWait="10000"
	|		|		|			 usernmae="root" password="root" driverClassName="com.mysql.jdbc.Driver"
	|		|		|			 url="jdbc:mysql//localhost:3306/day13"/>		
	|		|
	|		|--把配置信息写在tomcat下的conf目录的context.xml中，所有应用都能使用此数据源
	|		|
	|		|--在当前应用META-INF中创建context.xml，只有当前应用可以使用
	|
	|
	|
	|--使用连接池
	|		<%
	|			Context ctx=new initialContext();
	|			DataSource ds=(DataSource)ctx.lookup("java:/comp/env/jdbc/day13");
	|			out.print(ds)
	|		%>
   	|	 	
```

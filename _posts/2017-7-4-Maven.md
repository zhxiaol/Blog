---
layout: post
title: maven
tags:
- java

categories: java
description: maven
---
## Maven
> 项目管理工具

##### 什么是maven
* Maven是基于POM（工程对象模型），通过一小段描述来对项目的代码、报告、文件进管理的工具。
* Maven是一个跨平台的项目管理工具，它是使用java开发的，它要依赖于jdk1.6及以上
* Maven主要有两大功能：管理依赖、项目构建。
* 依赖指的就是jar包。

##### 什么是构建
> 清理 编译 测试 报告 打包 部署

##### 项目构建的方式
* Eclipse
使用eclipse进行项目构建，相对来说，步骤比较零散，不好操作
* Ant
它是一个专门的项目构建工具，它可以通过一些配置来完成项目构建，这些配置要明确的告诉ant，源码包在哪？目标class文件应该存放在哪？资源文件应该在哪
* Maven
它是一个项目管理工具，他也是一个项目构建工具，通过使用maven，可以对项目进行快速简单的构建，它不需要告诉maven很多信息，但是需要安装maven去的规范去进行代码的开发。也就是说maven是有约束的。

#### Maven的安装配置
* 下载maven
官方网站：http://maven.apache.org
* 安装maven
第一步：安装jdk1.6及以上
第二步：将maven下载的压缩包进行解压缩
第三步：配置maven的环境变量MAVEN_HOME
第四步：配置maven的环境变量PATH
第五步：测试maven是否安装成功，在系统命令行中执行命令：mvn –v
* 配置maven
在maven中有两个配置文件：用户配置、全局配置（默认）
* 全局配置
在maven安装目录的conf里面有一个settings.xml文件，这个文件就是maven的全局配置文件。
该文件中配置来maven本地仓库的地址
默认在系统的用户目录下的${user.home}/.m2/repository中，该目录是本地仓库的目录。

* 用户配置
用户配置文件的地址：~/.m2/settings.xml(Mac一致)，该文件默认是没有，需要将全局配置文件拷贝一份到该目录下。
重新指定本地仓库地址，如果不指定，则默认是~/.m2/repository目录，如果用户配置文件不存在，则使用全局配置文件的配置。

#### 创建maven工程
##### Maven工程结构
```java
Project
   |--src（源码包）
   |   |--main（正常的源码包）
   |   |   |--java（.java文件的目录）
   |   |   |--resources（资源文件的目录）
   |   |
   |   |--test（测试的源码包）
   |	   |--java
   |       |--resources
   |       
   |--target（class文件、报告等信息存储的地方）
   |--pom.xml（maven工程的描述文件）
```

##### 创建HelloMaven工程
第一步：安装maven的工程结构创建helloMaven工程
第二步：创建HelloMaven.java
第三步：创建TestHelloMaven.java
第四步：编辑pom.xml文件

#### Maven命令
Maven的命令要在pom.xml所在目录中去执行
|命令|说明|
|----|----|
|Mvn compile|编译的命令|
|Mvn clean|清除命令，清除已经编译好的class文件，具体说清除的是target目录中的文件|
|Mvn test|测试命令，该命令会将test目录中的源码进行编译|
|Mvn package|打包命令|
|Mvn install|安装命令，会将打好的包，安装到本地仓库|
|Mvn clean compile|先清空再编译|
|mvn clean test|先执行clean，再执行test，通常应用于测试环节|
|mvn clean package|先执行clean，再执行package，将项目打包，通常应用于发布前|
|mvn clean install|先执行clean，再执行install，将项目打包，通常应用于发布前|

```java
mvn clean package
    执行过程：
      清理————清空环境
      编译————编译源码
      测试————测试源码
      打包————将编译的非测试类打包

cmd mvn clean install
   执行过程：
      清理————清空环境
      编译————编译源码
      测试————测试源码
      打包————将编译的非测试类打包
      部署————将打好的包发布到资源仓库中
```


##### M2Eclipse
* 安装M2Eclipse
第一步：将目录中的m2e,m2e-extras文件拷贝
第二步：拷贝到eclipse中的dropins目录
第三步：查看eclipse中是否安装成功
第四步：设置maven的安装路径
第五步：设置maven的用户配置




#### 创建MavenFirst工程(IDEA)
* New Project选择Maven 勾选Create from archetype
* 选择maven-archetype-quickstart next
* 填写groupid(com.itheima.maven) artifactId(MevanFirst)
* shift+commend+a 搜索Maven Project 点击m按钮 输入指令complie test package install
###### pom.xml
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.itheima.maven</groupId>
  <artifactId>MavenFirst</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>

  <name>MavenFirst</name>
  <url>http://maven.apache.org</url>

  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.9</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>RELEASE</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>RELEASE</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
    </dependency>
  </dependencies>
</project>
```


#### 创建MavenSecond工程
* New Project选择Maven 不勾选Create from archetype
```java
//pom.xml
<dependency>
    <groupId>com.itheima.maven</groupId>
    <artifactId>MavenFirst</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>

//MavenSecond
public class MavenSecond {
    public String sayHello(String name){
        MavenFirst first = new MavenFirst();
        return first.sayHello(name);
    }
}
```

#### Maven的核心概念
##### 坐标
在平面几何中坐标（x,y）可以标识平面中唯一的一点。在maven中坐标就是为了定位一个唯一确定的jar包。
Maven世界拥有大量构建，我们需要找一个用来唯一标识一个构建的统一规范
拥有了统一规范，就可以把查找工作交给机器

##### Maven坐标主要组成
* groupId：定义当前Maven组织名称
* artifactId：定义实际项目名称
* version：定义当前项目的当前版本

#### 依赖管理
##### 依赖范围
其中依赖范围scope 用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下：
* compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效
* test：测试依赖范围。只对于测试classpath有效
* provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api
* runtime:运行时提供。例如:jdbc驱动

|依赖范围|主代码有效|测试代码有效|运行时有效|例子|
|-------|-----------------|----------|---------|---|
|complie|有|有|有|log4j|
|test|无|有|无|junit|
|provided|有|有|无|servlet-api|
|runtime|无|无|有|JDBC DRIVER Implementation|

#### 依赖传递
B工程依赖A工程，C工程依赖B工程，那么B工程是C工程的直接依赖，A工程是C工程的间接依赖

##### 创建MavenThird工程
```java
//pom.xml
<dependency>
    <groupId>com.itheima.maven</groupId>
    <artifactId>MavenSecond</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
//MavenThird
public class MavenThird {
    public String sayHello(String name){
        MavenSecond second = new MavenSecond();
        return second.sayHello(name);
    }
}
```

#### 依赖范围传递
```java
MavenThird-------MavenSecond------------MavenFirst                            
	|		 |				 |			 |
	|	     |  				 |			 |
	|	 第一直接依赖         第二直接依赖		 |
	|							 			 |
	|										 |
    ----------------  间接依赖  ---------------		
```

总结：
* 当第二依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。
* 当第二直接依赖的范围是test的时候，依赖不会得以传递。
* 当第二依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，且传递性依赖的范围同样为 provided；
* 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递的依赖范围为runtime；



##### 依赖冲突
在maven中存在两种冲突方式：一种是跨pom文件的冲突，一致是同一个pom文件中的冲突。

* 跨pom文件的冲突
MavenFirst的pom文件中依赖来junit的4.9版本，那边MavenSecond和MavenThird中都是使用了4.9版本。
如果MavenSecond中重新依赖junit的4.8版本，那么MavenSecond和MavenThird中都是使用了4.8本
这体现来依赖的就近使用原则。

* 同一个pom文件的冲突 加载从上往下,后面覆盖前面


##### 可选依赖
Optional标签标示该依赖是否可选，默认是false。可以理解为，如果为true，则表示该依赖不会传递下去，如果为false，则会传递下去。



##### 排除依赖
Exclusions标签可以排除依赖


#### 生命周期
* Maven有三个生命周期：clean生命周期、default生命周期、site生命周期
* 生命周期可以理解为项目构建的步骤集合。
* 生命周期是由多个阶段（Phase）组成。每个阶段都是一个完整的功能，比如mvn clean中的clean就是一个阶段。

##### Clean生命周期
* pre-clean 执行一些需要在clean之前完成的工作
* clean 移除所有上一次构建生成的文件
* post-clean 执行一些需要在clean之后立刻完成的工作
mvn clean命令，等同于 mvn pre-clean clean。只要执行后面的命令，那么前面的命令都会执行，不需要再重新去输入命令。
有Clean生命周期，在生命周期又有clean阶段。

##### Default生命周期（重点）
validate
generate-sources
process-sources
generate-resources
process-resources 复制并处理资源文件，至目标目录，准备打包。
compile 编译项目的源代码。
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources 复制并处理资源文件，至目标测试目录。
test-compile 编译测试源代码。
process-test-classes
test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。
prepare-package
package 接受编译好的代码，打包成可发布的格式，如 JAR 。
pre-integration-test
integration-test
post-integration-test
verify
install 将包安装至本地仓库，以让其它项目依赖。
deploy 将最终的包复制到远程的仓库，以让其它开发人员与项目共享。
在maven中，只要在同一个生命周期，你执行后面的阶段，那么前面的阶段也会被执行，而且不需要额外去输入前面的阶段，这样大大减轻了程序员的工作。

##### Site生命周期
* pre-site 执行一些需要在生成站点文档之前完成的工作
* site 生成项目的站点文档
* post-site 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
* site-deploy 将生成的站点文档部署到特定的服务器上



#### 插件
插件（plugin），每个插件都能实现一个阶段的功能。Maven的核心是生命周期，但是生命周期相当于主要指定了maven命令执行的流程顺序，而没有真正实现流程的功能，功能是有插件来实现的。
比如：compile就是一个插件实现的功能。
##### 编译插件
```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <source>1.7</source>
                <target>1.7</target>
                <encoding>UTF-8</encoding>
            </configuration>
        </plugin>
    </plugins>
</build>
```


##### Tomcat插件
如果使用maven的tomcat插件的话，那么本地则不需要安装tomcat。
## 创建maven的web工程
* 第一步：创建maven工程
* 第二步：main下面创建webapp/WEB-INF/web.xml
* 第三步: 在pom.xml中配置&lt;packaging>war&lt;/packaging>

##### 使用tomcat插件运行web工程
默认输入tomcat:run去使用tomcat插件来启动web工程，但是默认的tomcat插件使用的tomcat版本是tomcat6
而目前主流的tomcat，是使用的tomcat7，需要手动配置tomcat插件
使用tomcat7来运行web工程，它的命令是：tomcat7:run

##### 继承
在maven中的继承，指的是pom文件的继承

* 创建父工程
父工程的packaging为pom
* 创建子工程
创建子工程有两种方式：一种是创建一个新的工程为子工程，另一种是修改老的工程为子工程。
子工程的pom文件
```xml
<parent>
    <groupId>com.itheima.maven</groupId>
    <artifactId>MavenParent</artifactId>
    <version>1.0-SNAPSHOT</version>
</parent>
```
##### 父工程统一依赖jar包
在父工程中对jar包进行依赖，在子工程中都会继承此依赖。
```xml
<packaging>pom</packaging>
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.9</version>
    </dependency>
</dependencies>
```
##### 父工程统一管理版本号
dependencyManagement标签管理的依赖，其实没有真正依赖，它只是管理依赖的版本。
```xml
//父工程
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.9</version>
        </dependency>
    </dependencies>
</dependencyManagement>

//子工程
<dependencies>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
    </dependency>
</dependencies>
```

##### 父工程抽取版本号
```xml
<properties>
    <junit.vsersion>4.9</junit.vsersion>
</properties>
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>${junit.vsersion}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```



#### 聚合
在真实项目中，一个项目有表现层、业务层、持久层，
对于业务层和持久层，它们可以在多个工程中被使用，
所以一般会将业务层和持久单独创建为java工程，为其他工程依赖。

##### 创建一个聚合工程
```xml
//MavenWeb2
<modules>
    <module>../MavenDao</module>
    <module>../MavenService</module>
    <module>../MavenController</module>
</modules>
<!--聚合工程打包方式必须是pom-->
<packaging>pom</packaging>

//MavenDao
<parent>
    <artifactId>MavenWeb2</artifactId>
    <groupId>com.itheima.maven</groupId>
    <version>1.0-SNAPSHOT</version>
    <relativePath>../MavenWeb2/pom.xml</relativePath>
</parent>
//MavenService
<parent>
    <artifactId>MavenWeb2</artifactId>
    <groupId>com.itheima.maven</groupId>
    <version>1.0-SNAPSHOT</version>
    <relativePath>../MavenWeb2/pom.xml</relativePath>
</parent>
//MavenController
<parent>
    <artifactId>MavenWeb2</artifactId>
    <groupId>com.itheima.maven</groupId>
    <version>1.0-SNAPSHOT</version>
    <relativePath>../MavenWeb2/pom.xml</relativePath>
</parent>
<packaging>war</packaging>
```


#### Maven仓库管理
用来统一存储所有Maven共享构建的位置就是仓库。根据Maven坐标定义每个构建在仓库中唯一
存储路径大致为：groupId/artifactId/version/artifactId-version.packaging

##### 仓库的分类
* 本地仓库
默认在~/.m2/repository，如果在用户配置中有配置，则以用户配置的地址为准
* 远程仓库
  中央仓库（不包含有版本的jar包）
  http://repo1.maven.org/maven2
  私服
  本地有使用本地,没有私服去中央仓库下载




##### Maven私服安装
安装Nexus
为所有来自中央仓库的构建安装提供本地缓存。
下载网站：http://nexus.sonatype.org/

* 第一步：安装tomcat
* 第二步：将nexus的war包拷贝到tomcat的webapps下
* 第三步：启动tomcat
* 第四步：nexus的本地目录 ~/.m2/

##### 访问Nexus
访问URL: http://localhost:8080/nexus-2.7.0-06/

默认账号:
用户名： admin
密码： admin123

##### Nexus的仓库和仓库组

仓库有4种类型 :
* group(仓库组)：一组仓库的集合
* hosted(宿主)：配置第三方仓库 （包括公司内部私服 ）
* proxy(代理)：私服会对中央仓库进行代理，用户连接私服，私服自动去中央仓库下载jar包或者插件
* virtual(虚拟)：兼容Maven1 版本的jar或者插件

##### Nexus的仓库和仓库组介绍:
3rd party: 一个策略为Release的宿主类型仓库，用来部署无法从公共仓库获得的第三方发布版本构建
Apache Snapshots: 一个策略为Snapshot的代理仓库，用来代理Apache Maven仓库的快照版本构建
Central: 代理Maven中央仓库
Central M1 shadow: 代理Maven1 版本 中央仓库
Codehaus Snapshots: 一个策略为Snapshot的代理仓库，用来代理Codehaus Maven仓库的快照版本构件
Releases: 一个策略为Release的宿主类型仓库，用来部署组织内部的发布版本构件
Snapshots: 一个策略为Snapshot的宿主类型仓库，用来部署组织内部的快照版本构件
Public Repositories:该仓库组将上述所有策略为Release的仓库聚合并通过一致的地址提供服务



##### 配置所有构建均从私服下载
```xml
在本地仓库(~/.m2)的setting.xml中配置如下：
<mirrors>
    <mirror>
       <!--此处配置所有的构建均从私有仓库中下载 *代表所有，也可以写central -->
       <id>nexus</id>
       <mirrorOf>*</mirrorOf>
       <url>http://localhost:8080/nexus-2.7.0-06/content/groups/public/</url>
    </mirror>
 </mirrors>
```





##### 部署构建到Nexus
* 第一步：Nexus的访问权限控制
在本地仓库的setting.xml中配置如下：
```xml
   <server>
      <id>releases</id>
      <username>admin</username>
      <password>admin123</password>
   </server>
   <server>
      <id>snapshots</id>
      <username>admin</username>
      <password>admin123</password>
   </server>
```
* 第二步：配置pom文件
在需要构建的项目中修改pom文件
```xml
<distributionManagement>
      <repository>
         <id>releases</id>
         <name>Internal Releases</name>
         <url>http://localhost:8080/nexus-2.7.0-06/content/repositories/releases/</url>
      </repository>
      <snapshotRepository>
         <id>snapshots</id>
         <name>Internal Snapshots</name>
         <url>http://localhost:8080/nexus-2.7.0-06/content/repositories/snapshots/</url>
      </snapshotRepository>
   </distributionManagement>
```

* 第三步：执行maven的deploy命令

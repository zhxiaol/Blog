---
layout: post
title: Spring IOC控制反转和依赖注入
tags:
- java

categories: java
description: Spring IOC控制反转和依赖注入
---
## 什么是Sping
Spring的核心是控制反转（IoC）和面向切面（AOP）。
Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。
轻量级:依赖的资源少，消耗的资源少。
分层:web层，service层，dao层

## Spring优点
1. 方便解耦，简化开发
1. AOP编程的支持
1. 声明式事务的支持
1. 方便集成各种优秀的框架
1. 降低JavaEEAPI的使用难度


## 导入jar包
> 4+1 4个核心：Beans,Core,Context,Expression 一个依赖:Common-loggin

## 配置文件
> 位置:任意，开发中一般默认在src下
> 名称:任意，开发中常用applicationContext.xml
> 内容:添加约束，schame 位置:spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\ xsd-config.html

## 什么是Sping
Spring的核心是控制反转（IoC）和面向切面（AOP）。
Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。
轻量级:依赖的资源少，消耗的资源少。
分层:web层，service层，dao层

## Spring优点
1. 方便解耦，简化开发
1. AOP编程的支持
1. 声明式事务的支持
1. 方便集成各种优秀的框架
1. 降低JavaEEAPI的使用难度


## 导入jar包
> 4+1 4个核心：Beans,Core,Context,Expression 一个依赖:Common-logging

## 配置文件
> 位置:任意，开发中一般默认在src下
> 名称:任意，开发中常用applicationContext.xml
> 内容:添加约束，schame 位置:spring-framework-3.2.0.RELEASE\docs\spring-framework-reference\html\ xsd-config.html
```
public interface UserService {
    public void addUser();
}
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("a_ioc addUser");
    }
}

<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

<!--配置service <bean>配置需要创建的对象 id:用于之后从spring容易获得实例时使用的-->
    <bean id="userServiceId" class="com.itheima.a_ioc.UserServiceImpl"></bean>
</beans>

public class TestIoc {
    @Test
    public void demo01(){
        UserService us=new UserServiceImpl();
        us.addUser();
    }

    @Test
    public void demo02(){
        String xmlPath="com/itheima/a_ioc/beans.xml";
        //获得容器
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        //获得内容
        UserService us= (UserService) applicationContext.getBean("userServiceId");
        us.addUser();
    }
}
```

## DI 依赖注入
> is a:是一个，继承  has a:有一个成员变量，依赖
> 依赖:一个对象需要使用另一个对象
> 注入:通过setter方法进行另一个实例设置

```
public interface BookService {
    void addBook();
}

public class BookServiceImpl implements BookService {
    private BookDao dao;
    @Override
    public void addBook() {
        dao.save();
    }

    public void setDao(BookDao dao) {
        this.dao = dao;
    }
}

public interface BookDao {
    void save();
}

public class BookDaoImpl implements BookDao {
    @Override
    public void save() {
        System.out.println("bookDaoImpl save");
    }
}

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="bookServiceId" class="com.itheima.b_di.BookServiceImpl">
        <property name="dao" ref="bookDaoId"/>
    </bean>
    <bean id="bookDaoId" class="com.itheima.b_di.BookDaoImpl"></bean>
</beans>


public class TestDI {
    @Test
    public void demo01(){
        String xmlPath="com/itheima/b_di/beans.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        BookService bs= (BookService) applicationContext.getBean("bookServiceId");
        bs.addBook();
    }
}
```


## 核心API
BeanFactory:这是一个工厂，用于生产Bean
ApplicationContext:是BeanFactory的子接口，功能更强大。当配置文件加载对象就被创建
ClassPathXmlApplicationContext:用于加载classpath(类路径,src)下的指定xml 运行时:WEB-INF/classes..
FileSystemXmlAppliationContext:用于加载指定盘符的xml 运行时:WEB-INF/...
```
@Test
public void demo02(){
    String xmlPath="com/itheima/b_di/beans.xml";
    BeanFactory factory=new XmlBeanFactory(new ClassPathResource(xmlPath));//延迟加载 第一次调用getBean实例化
    BookService bs = (BookService) factory.getBean("bookServiceId");
    bs.addBook();
}
```

Bean的实例化方式
1. 默认构造
2. 静态工厂
3. 实例工厂

###### 静态工厂

```
public class MyBeanFactory {
    //静态工厂-创建实例
    public static UserService createService(){
        return new UserServiceImpl();
    }
}

public class TestStaticFactory {
    @Test
    public void demo01(){//自定义工厂
        UserService service = MyBeanFactory.createService();
        service.addUser();
    }
    @Test
    public void demo02(){//Spring工厂
        String xmlPath="com/itheima/c_inject/b_static_factory/beans.xml";
        ApplicationContext appctx=new ClassPathXmlApplicationContext(xmlPath);
        UserService us = appctx.getBean("userService", UserService.class);
        us.addUser();

    }
}

//bean.xml
<bean id="userService" class="com.itheima.c_inject.b_static_factory.MyBeanFactory" factory-method="createService"></bean>
```
###### 实例工厂
```
public class MyBeanFactory {
    //实例工厂-创建实例
    public UserService createService(){
        return new UserServiceImpl();
    }
}

public class TestStaticFactory {
    @Test
    public void demo01(){//自定义工厂
        UserService service = new MyBeanFactory().createService();
        service.addUser();
    }
    @Test
    public void demo02(){//Spring工厂
        String xmlPath="com/itheima/c_inject/c_factory/beans.xml";
        ApplicationContext appctx=new ClassPathXmlApplicationContext(xmlPath);
        UserService us = appctx.getBean("userService", UserService.class);
        us.addUser();

    }
}

//bean.xml
<!--创建工厂实例-->
<bean id="myBeanFactory" class="com.itheima.c_inject.c_factory.MyBeanFactory"></bean>
<!--获得userService-->
<bean id="userService" factory-bean="myBeanFactory" factory-method="createService"></bean>
```

## Bean的种类
```
Bean的种类
	|
	|--普通bean
	|	  |
	|	  |--<bean id="" class=> spring直接创建实例并返回
	|
	|
	|
	|--FactoryBean
		  |
		  |--是一个特殊的bean,具有工厂生产对象的能力，只能生产特定的对象
		  |
		  |--bean:实现使用FactoryBean接口，此接口提供方法getObject()用于获得特定的bean
		  |
		  |--<bean id="" class="FB"> 先创建FB实列，使用调用getObject()方法，并返回方法的返回值
		  |
		  |--BeanFactory和FactoryBean
		  			|
		  			|--BeanFactory:工厂，用于生产任意bean
		  			|
		  			|--FacotryBean:特殊bean,用于生产另一个特定的bean
		  					|
		  					|--ProxyFactoryBean,此工厂bean用于生产代
```

## 作用域
> 用于spring创建实例的个数
|类别|说明|
|---|----|
|singleton|Bean以单例方式存在|
|prototype|每次调用getBean()都创建一个实例|
|request|每次Http请求都创建一个新的Bean|
|session|同一个session共享一个Bean|
|globalSession|一般用于protlet应用|
```
//bean.xml
<bean id="userService" class="com.itheima.c_inject.d_scope.UserServiceImpl"
scope="prototype"></bean>

//Test01.java
@Test
public void demo02(){
    String xmlPath="com/itheima/c_inject/d_scope/beans.xml";
    ApplicationContext appctx=new ClassPathXmlApplicationContext(xmlPath);
    UserService us1 = appctx.getBean("userService", UserService.class);
    UserService us2 = appctx.getBean("userService", UserService.class);
    System.out.println(us1);
    System.out.println(us2);
}

```

## 声明周期

```
生命周期
	|
	|--初始化和销毁方法
			|
			|--目标方法执行前后执行后，将执行初始化或销毁
			|
			|--<bean id="" class="" init-method="初始化方法名称" destory-method="销毁方法名称">
					|
					|--init-method:准备资源
					|--destory-method:清理资源


BeanPostProcessor 后处理Bean
```

```
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("e_cycle addUser");
    }
    public void myInit(){
        System.out.println("我的初始化");
    }
    public void myDestory(){
        System.out.println("我的销毁");
    }
}

//bean.xml
<bean id="userService" class="com.itheima.c_inject.e_lifecycle.UserServiceImpl"
      init-method="myInit" destroy-method="myDestory" scope="prototype"
></bean>


@Test
public void demo02() throws Exception{
    String xmlPath = "com/itheima/c_inject/e_lifecycle/beans.xml";
    ApplicationContext app = new ClassPathXmlApplicationContext(xmlPath);
    UserService service = (UserService) app.getBean("userService");
    service.addUser();
    //此方法接口没有定义，实现类定义了
   // app.getClass().getMethod("close").invoke(app);
    ((ClassPathXmlApplicationContext)app).close();
}
```

## BeanPostProcessor 后处理Bean
> spring提供一种机制，只要实现此接口，并将实现类提供spring容器，spring容器自动执行
> 在初始化执行之前beofre(),只执行方法之后执行aflter()
> spring提供的工厂钩子，用于修改实例对象，可以生成代理对象，是AOP底层
> <bean id="" class=""/>
> 默认作用于所有的bean 通过alter()方法的beanName进行判断选择作用与谁  

###### 模拟

```
A a=new A();
a =B.before(a); -->将a的实例对象传递后处理bean,可以生成代理对象并返回
a.init();
a =B.aflter();
a.addUser();--> 生成代理对象，目的在目标方法前后执行(事务管理)

步骤
 |
 |--编写BeanPostProcessor的实现类
 |
 |--配置
 	 |--<bean  class="BeanPostProcessor的实现类"

```

```
public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object o, String s) throws BeansException {
        System.out.println("前方法: "+s);
        return o;
    }

    @Override
    public Object postProcessAfterInitialization(final Object o, String s) throws BeansException {
        System.out.println("后方法: "+s);
        return Proxy.newProxyInstance(o.getClass().getClassLoader(), o.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("---------开启事务");
                Object proxyObject = method.invoke(o, args);
                System.out.println("---------提交事务");
                return proxyObject;
            }
        });
    }
}

//bean.xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userService" class="com.itheima.c_inject.e_lifecycle.UserServiceImpl"
          init-method="myInit" destroy-method="myDestory" scope="prototype"
    ></bean>
    <bean class="com.itheima.c_inject.e_lifecycle.MyBeanPostProcessor"/>
</beans>

public class TestCycle {
    @Test
    public void demo02() throws Exception{
        String xmlPath = "com/itheima/c_inject/e_lifecycle/beans.xml";
        ApplicationContext app = new ClassPathXmlApplicationContext(xmlPath);
        UserService service = (UserService) app.getBean("userService");
        service.addUser();
        //此方法接口没有定义，实现类定义了
       // app.getClass().getMethod("close").invoke(app);
        ((ClassPathXmlApplicationContext)app).close();
    }
}
```

## 属性的依赖注入
> 依赖注入方式:手动装配和自动装配
> 手动装配:一般采用手动 分为:基于xml的装配 基于注解装配
> 自动装配:struts和spring整合可以自动装配

## 构造注入
```

构造注入
  |
  |--<bean>
  	   |
  	   |--<constructor-arg name="" value="" index="" type=""/>
  	   			|
  	   			|--name:参数名称
  	   			|--value:设置普通数据
  	   			|--rel:引用数据，一般是另一个bean id的值
  	   			|--index:参数的索引号,从0开始。如果只有索引，匹配到了多个构造方法，默认使用第一个
  	   			|--type:确定参数类型
```
```
//User.java
public class User {
    private Integer uid;
    private String username;
    private Integer age;

    public User(Integer uid, String username) {
        this.uid = uid;
        this.username = username;
    }

    public User(String username, Integer age) {
        this.username = username;
        this.age = age;
    }


//TestCons.java
@Test
public void demo02() throws Exception{
    String xmlPath="com/itheima/c_inject/f_xml/a_constructor/beans.xml";
    ApplicationContext app=new ClassPathXmlApplicationContext(xmlPath);
    User user= (User) app.getBean("user");
    System.out.println(user);

}



//bean.xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--
       用于配置构造方法的的一个参数
       name:参数名称
       value:设置普通数据
       rel:引用数据，一般是另一个bean id的值
       index:参数的索引号,从0开始。如果只有索引，匹配到了多个构造方法，默认使用第一个
       type:确定参数类型
        -->
    <bean id="user" class="com.itheima.c_inject.f_xml.a_constructor.User">
        <constructor-arg index="0" value="1" type="java.lang.String"/>
        <constructor-arg index="1" value="2" type="int"/>
    </bean>
</beans>
```
## Setter方法
```
public class Person {
    private String pname;
    private Integer age;
    private Address homeAddr;
    private Address companyAddr;
}

public class Address {
    private String addr;
    private String tel;
}

//bean.xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="person" class="com.itheima.c_inject.f_xml.b_setter.Person">
        <property name="pname" value="阳志"/>
        <property name="age">
            <value>123</value>
        </property>
        <property name="homeAddr" ref="homeAddr"/>
        <property name="companyAddr">
            <ref bean="companyAddr"/>
        </property>
    </bean>
    <bean id="homeAddr" class="com.itheima.c_inject.f_xml.b_setter.Address">
        <property name="addr" value="阜南"/>
        <property name="tel" value="991"/>
    </bean>
    <bean id="companyAddr" class="com.itheima.c_inject.f_xml.b_setter.Address">
        <property name="addr" value="北京八宝山"/>
        <property name="tel" value="120"/>
    </bean>
</beans>

public class TestSetter {
    @Test
    public void demo01(){
        String xmlPath="com/itheima/c_inject/f_xml/b_setter/beans.xml";
        ApplicationContext app=new ClassPathXmlApplicationContext(xmlPath);
        Person p= (Person) app.getBean("person");
        System.out.println(p);
    }
}
```

## P命令空间
> 对setter方法进行简化,替换<property name="属性名">,而是在<bean p:属性名=“普通值” p:属性名-ref="引用值">
> p命名空间使用的前提,必须添加命名空间
```
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="person" class="com.itheima.c_inject.f_xml.c_p.Person"
          p:pname="与泰普" p:age="22"
          p:homeAddr-ref="homeAddr" p:companyAddr-ref="companyAddr">
    </bean>
    <bean id="homeAddr" class="com.itheima.c_inject.f_xml.c_p.Address"
          p:addr="DG" p:tel="10010">
    </bean>
    <bean id="companyAddr" class="com.itheima.c_inject.f_xml.c_p.Address"
          p:addr="DG" p:tel="10086">
    </bean>
</beans>
```

## SpEl
> 对<property>进行统一编程 所有的内容都使用value
> &lt;property name="" value="#{表达式}">
|表达式|说明|
|-------|------|
|\#{123}|数字|
|\#{'jack'}|字符串|
|\#{beanId}|另一个bean的引用|
|\#{beanId.propName}|操作数据|
|\#{beanid.toString()|执行方法|
|\#{beanid.name?.toUpperCase()|如果属性不为空就调用|
|\#{T(静态类).字段\|方法|静态字段或方法|

```
public class Customer  {
    private String cname="jack";
    private Double pi;
}
//TestSPEL.java
public void demo02() throws Exception{
    String xmlPath="com/itheima/c_inject/f_xml/d_spel/beans.xml";
    ApplicationContext app=new ClassPathXmlApplicationContext(xmlPath);
    Customer c= (Customer) app.getBean("customer");
    System.out.println(c);

}

//Bean.xml
<bean id="customer" class="com.itheima.c_inject.f_xml.d_spel.Customer">
    <property name="cname" value="#{customer.cname?.toUpperCase()}"/>
    <property name="pi" value="#{T(java.lang.Math).PI}"/>
</bean>
```

## 集合注入
> 集合的注入都是给<property>添加子标签
```
<bean id="collData" class="com.itheima.c_inject.f_xml.e_coll.CollData">
    <property name="arrData">
        <array>
            <value>DS</value>
            <value>DZD</value>
            <value>屌丝</value>
            <value>屌中屌</value>
        </array>
    </property>
    <property name="listData">
        <list>
            <value>孙悟空</value>
            <value>猪八戒</value>
            <value>沙和尚</value>
            <value>白龙马</value>
        </list>
    </property>
    <property name="setData">
        <set>
            <value>鸣人</value>
            <value>佐助</value>
            <value>卡卡西</value>
            <value>我爱罗</value>
        </set>
    </property>
    <property name="mapData">
        <map>
            <entry key="佩恩" value="神罗天征"></entry>
            <entry>
                <key>
                    <value>三代火影</value>
                </key>
                <value>尸鬼封尽</value>
            </entry>
            <entry key="大蛇丸" value="碎土转生"></entry>
            <entry key="宇智波鼬" value="须佐之男"></entry>
        </map>
    </property>
    <property name="propsData">
        <props>
            <prop key="碎蜂">尽敌螯杀</prop>
            <prop key="蓝染">镜花水月</prop>
            <prop key="白哉">千本樱</prop>
            <prop key="山本元柳斎重国">流刃若火</prop>
        </props>
    </property>
</bean>
```

## 装配Bean基于注解
> 注解:就是一个类，使用@注解名称
> 使用注解取代xml配置文件
> 注解使用前提，添加命名空间，让spring扫描含有注解的类
|注解|说明|
|---|----|
|@Component|取代&ltg;bean class="">|
|@Component("id")|取代&ltg;bean id="id" class="">|
|web开发||
|@Repository|web开发:dao层,取代&ltg;bean id="id" class="">|
|@Service|web开发:service层,取代&ltg;bean id="id" class="">|
|@Controller|web开发:web层,取代&ltg;bean id="id" class="">|
|依赖注入|给私有字段设置，也可以给setter方法设置|
|@Value("")|普通值注入|
|@AutoWired|按照类型注入|
|@AutoWired@Qualifier("名称")|按照名称注入|
|@Resource("名称")|按照名称注入|
|生命周期||
|@PostConstruct|初始化|
|@PreDestoy|销毁|
|@Scope("prototype ")|作用域,多列|

```
public interface UserService {
    public void addUser();
}
@Component("userServiceId")
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("a_ioc addUser");
    }
}
<context:component-scan base-package="com.itheima.c_inject.f_xml.g_annotation.a_ioc"></context:component-scan>
@Test
public void demo02(){
    String xmlPath="com/itheima/c_inject/f_xml/g_annotation/a_ioc/beans.xml";
    //获得容器
    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
    //获得内容
    UserService us= (UserService) applicationContext.getBean("userServiceId");
    us.addUser();
}
```

```
@Controller("studentAction")
public class StudentAction {
    @Autowired
    private StudentService service;
    public void execute(){
        System.out.println("StudenAction");
        service.addStudent();
    }
}
public interface StudentService  {
    void addStudent();
}


@Service
public class StudentServiceImpl implements StudentService {
    private StudentDao dao;
    @Override
    public void addStudent() {
        System.out.println("studentService");
        dao.save();
    }
    @Autowired
    @Qualifier("studentDaoId")
    public void setDao(StudentDao dao) {
        this.dao = dao;
    }
}


public interface StudentDao {
    void save();
}



@Repository("studentDaoId")
public class StudentDaoImpl implements StudentDao {

    @Override
    public void save() {
        System.out.println("studentDao");
    }
}
<context:component-scan base-package="com.itheima.c_inject.f_xml.g_annotation.b_web"></context:component-scan>

@Test
public void demo02(){
    String xmlPath="com/itheima/c_inject/f_xml/g_annotation/b_web/beans.xml";
    //获得容器
    ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
    //获得内容
    StudentAction studentAction= (StudentAction) applicationContext.getBean("studentAction");
    studentAction.execute();
}
```

```
public interface UserService {
    public void addUser();
}

@Service("userServiceId")
@Scope("prototype")
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("a_ioc addUser");
    }
    @PostConstruct
    public void myInit(){
        System.out.println("初始化");
    }
    @PreDestroy
    public void myDestory(){
        System.out.println("销毁");
    }
}

@Test
public void demo02(){
    String xmlPath="com/itheima/c_inject/f_xml/g_annotation/c_other/beans.xml";
    //获得容器
    ClassPathXmlApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
    //获得内容
    UserService us1= (UserService) applicationContext.getBean("userServiceId",UserService.class);
    UserService us2= (UserService) applicationContext.getBean("userServiceId",UserService.class);
    System.out.println(us1);
    System.out.println(us2);
    applicationContext.close();

}

<context:component-scan base-package="com.itheima.c_inject.f_xml.g_annotation.c_other"></context:component-scan>
```
















1.将所有的bean都配置xml中


       <bean
id="" class="">


2.将所有的依赖都使用注解


       @Autowired


       默认不生效。为了生效，需要在xml配置：<context:annotation-config>





总结：


注解1：<context:component-scan
base-package=" ">


注解2：<context:annotation-config>


1.一般情况两个注解不一起使用。


2. “注解1”扫描含有注解（@Component
等）类，注入注解自动生效。


       “注解2”只在xml和注解（注入）混合使用时，使注入注解生效。

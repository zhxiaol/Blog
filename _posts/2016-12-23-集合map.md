---
layout: post
title: 集合Map
tags:
- java

categories: java
description:
---
## Map接口和Collection接口的不同
* Map是双列的,Collection是单列的
* Map的键唯一,Collection的子体系Set是唯一的
* Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效

| 方法     | 备注    |
| :------------- | :------------- |
| V put(K key,V value)    | 如果键是第一次存储，就直接存储元素，返回null，如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值|
|void clear()|移除所有的键值对元素|
|V remove(Object key)|根据键删除键值对元素，并把值返回|
|boolean containsKey(Object key)|判断集合是否包含指定的键|
|boolean containsValue(Object value)|判断集合是否包含指定的值|
|boolean isEmpty()|判断集合是否为空|
|Set<Map.Entry<K,V>> entrySet()|获取键值对集合|
| V get(Object key):|根据键获取值|
|Set<K> keySet()|获取集合中所有键的集合|
|Collection<V> values()|获取集合中所有值的集合|
|int size()|返回集合中的键值对的个数|

## Map遍历
* 获得键集合迭代找值
* 获得键值对集合迭代

## HashMap
内部是一个数组，数组存储的是键值对Entry
hashCode计算下标，equals判断键的唯一性

## LinkedHashMap
HashMap的子类，Entry里面存储了他前面键值对和它后面的键值对
保证怎么存就怎么取，顺序不变

## TreeMap
如果传入Comparator, 就优先按照Comparator比较
如果没有传入，添加的时候会把元素强转成Comparable比较
二叉树，Entry除了保存自身键值对还会保存它左右两边的键值对

## Hashtable
* Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高
* Hashtable不可以存储null键和null值,HashMap可以存储null键和null值

## Collections

| 方法 | 备注     |
| :------------- | :------------- |
|void sort(List<T> list)| 排序,调用Arrays.sort()|
|binarySearch(List<?> list,T key)|集合要有序，如果没有返回-(插入点)-1|
|max(Collection<?> coll)|迭代compareTo比较|
|reverse(List<?> list)|反转|
|shuffle(List<?> list)|洗牌|

## 练习
###### 统计字符串每个字符出现的次数
```java
String s="aabbbcccc";
char[]chars=s.toCharArray();
HashMap<Character,Integer>hm=new HashMap<>();
for(char c:chars){
  hm.put(c,hm.containsKey(c)?hm.get(c)+1:1);
}
```
###### 模拟斗地主洗牌和发牌并对牌进行排序
```java
String[] nums = {"3","4","5","6","7","8","9","10","J","Q","K","A","2"};
String[] colors = {"方片","梅花","红桃","黑桃"};
HashMap<Integer, String> hm = new HashMap<>();
ArrayList<Integer> list = new ArrayList<>();
int index = 0;
for(String num:nums){
  for(String color:colors){
      list.add(index);
      hm.put(index++,color.concat(num));
  }
}
list.add(index);
hm.put(index++,"小王");
list.add(index);
hm.put(index,"大王");
Collections.shuffle(list);//洗牌
TreeSet<Integer>user1=new TreeSet<>();
TreeSet<Integer>user2=new TreeSet<>();
TreeSet<Integer>user3=new TreeSet<>();
TreeSet<Integer>dipai=new TreeSet<>();
for(int i=0;i<list.size();i++){
  if(i>list.size()-3){
    dipai.add(list.get(i));
  }else if(i%3==0){
    user1.add(list.get(i));
  }else if(i%3==1){
    user2.add(list.get(i));
  }else{
    user3.add(list.get(i));
  }
}
for(int i:user1){//看牌
  System.out.print(hm.get(i)+" ")
}
```

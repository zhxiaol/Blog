---
layout: post
title: Oracle03
tags:
- java

categories: java
description: Oracle03
---
## PL/SQL
```
PL/SQL是一种块结构的语言。一个PL/SQL包含了一个或多个逻辑快，逻辑块中可以声明变量、写程序主体、
还可以捕获异常和异常处理。每个逻辑快分为三个部分declare begin exception
```
### 变量和常量
> 变量和说明变量中间添加 constant就是常量
|变量|说明变量|
|-----|----------|
|var1|char(15)|
|married|boolean:=true|
|psal|number(7,2)|
|my_name|emp.ename%type 引用型变量|
|emp_rec|emp%rowtype 记录型变量 一行可以当做一个数组|
##### 引用型变量
```sql
--查询7839的姓名和薪水
set serveroutput on --打开输出

declare
  --定义变量保存姓名和薪水
  --pename varchar2(20);
  --psal   number;
  pename emp.ename%type;
  psal   emp.sal%type;
begin
  --得到姓名和薪水
  select ename,sal into pename,psal from emp where empno=7839;

  dbms_output.put_line(pename||'的薪水是'||psal);
end;
/
```
##### 记录型变量
```sql
--查询7839的姓名和薪水
set serveroutput on

declare
  --定义记录型变量：代表一行
  emp_rec emp%rowtype;
begin
  select * into emp_rec from emp where empno=7839;
  dbms_output.put_line(emp_rec.ename||'的薪水是'||emp_rec.sal);
end;
/
```
## IF语句
###### 格式
```
if 条件 then 语句1; 语句2;end if;

if 条件 then  语句序列1:esle 语句序列2; end if;

if 条件 then 语句; elsif 语句 then 语句; else 语句; end if;

```
###### if案例
```
--判断用户从键盘输入的数字

set serveroutput on

--接收键盘输入
--num: 地址值，在该地址上 保存了输入的值
accept num prompt '请输入一个数字';

declare
  --定义变量保存输入的数字
  pnum number := &num;
begin
  if pnum = 0 then dbms_output.put_line('您输入的是0');
    elsif pnum = 1 then dbms_output.put_line('您输入的是1');
    elsif pnum = 2 then dbms_output.put_line('您输入的是2');
    else dbms_output.put_line('其他数字');
  end if;
end;
/
```

##### 循环语句
###### 格式
```plsql
//第一种
while total <=25000
loop
...
total:=total+salary;
end loop;


//第二种
loop
exit[when 条件];
...
end loop;


//第三种
for i in 1..3
loop
语句序列
end loop;
```

######循环案例
```plsql

set serveroutput on

declare
  pnum number := 1;
begin
  loop

    exit when pnum > 10;

    dbms_output.put_line(pnum);

    pnum := pnum + 1;
  end loop;
end;
/
```
###### 光标(Cursor)==ResultSet
|定义|说明|
|-----|-----|
|语法|cursor 光标名[(参数名 数据类型[,参数名 数据类型]...)] is select 语句:|
|用于|用于存储一个查询返回的多行数据|
|示例|cursor c1 is select ename from emp;|
|打开光标|open c1;(打开光标执行查询)|
|取一行光标的值|fetch c1 into pename;(取一行到变量中,取完光标下移,pename类型必须和ename类型一致);|
|关闭光标|close c1;(关闭游标释放资源)|
|光标的属性|c1%属性|
|%isopen|是否打开|
|%rowcount|影响的行数|
|%found|是否取到数据|
|%notfound|是否没取到数据|

###### 示例
```sql
--查询并打印员工的姓名和薪水
2. 默认，一个会话中只能打开300个光标
SQL> show parameter cursor
修改: alter system set open_cursors=400;

set serveroutput on
declare
  --定义光标
  cursor cemp is select ename,sal from emp;
  pename emp.ename%type;
  psal   emp.sal%type;
begin
  --打开光标
  open cemp;

  loop
    --取一条记录
    fetch cemp into pename,psal;
    --退出条件
    --exit when 没有取到记录;
    exit when cemp%notfound;

    dbms_output.put_line(pename||'的薪水是'||psal);

  end loop;

  --关闭光标
  close cemp;
end;
/

```

###### 涨工资
```sql
--涨工资，总裁1000 经理800 其他400
set serveroutput on

declare
  --alter table "SCOTT"."EMP" rename column "JOB" to empjob
  cursor cemp is select empno,empjob from emp;
  pempno emp.empno%type;
  pjob   emp.empjob%type;
begin
  rollback;

  open cemp;
  loop
    --取一条记录
    fetch cemp into pempno,pjob;
    exit when cemp%notfound;

    --判断职位
    if pjob = 'PRESIDENT' then update emp set sal=sal+1000 where empno=pempno;
      elsif pjob = 'MANAGER' then update emp set sal=sal+800 where empno=pempno;
      else update emp set sal=sal+400 where empno=pempno;
    end if;

  end loop;
  close cemp;

  --why?  ---> ACID
  commit;

  dbms_output.put_line('完成');
end;
/

```

###### 带参数的光标
```sql
--查询某个部门的员工姓名
set serveroutput on

declare
  cursor cemp(dno number) is select ename from emp where deptno=dno;
  pename emp.ename%type;
begin
  open cemp(20);
  loop
    fetch cemp into pename;
    exit when cemp%notfound;

    dbms_output.put_line(pename);

  end loop;
  close cemp;
end;
/
```
## 例外
例外是程序设计语言提供的一种功能,用来增强程序的健壮性和容错性

###### 系统定义例外
|例外|说明|
|-----|------|
|No_data_found|没有找到数据|
|Too_many_rows|select..into语句匹配多行|
|Zero_Divide|被零除|
|Value_error|算术或转换错误|
|Timeout_on_resource|在等待资源时发生超时|
###### 字体定义例外
```sql
--被0除
set serveroutput on

declare
  pnum number;
begin
  pnum := 1/0;

exception
  when zero_divide then dbms_output.put_line('1:0不能做分母');
                         dbms_output.put_line('2:0不能做分母');
  when value_error then dbms_output.put_line('算术或者转换错误');
  when others then dbms_output.put_line('其他例外');
end;
/
```
###### 自定义实例
```sql
--查询50号部门的员工姓名
set serveroutput on

declare
  cursor cemp is select ename from emp where deptno=50;
  pename emp.ename%type;

  --自定义例外
  no_emp_found exception;
begin
  open cemp;

  --取第一条记录
  fetch cemp into pename;

  if cemp%notfound then
    --抛出例外
    raise no_emp_found;
  end if;

  --pmon: process monitor
  close cemp;

exception
  when no_emp_found then dbms_output.put_line('没有找到员工');
  when others then dbms_output.put_line('其他例外');
end;
/
```
###### 案例1
```sql
/*
SQL语句：
select to_char(hiredate,'yyyy') from emp;
---> 集合 ---> 光标 ---> 循环  ---> 退出条件:notfound

变量：1. 初始值  2. 最终得到
每年入职的员工人数:
count80 number := 0;
count81 number := 0;
count82 number := 0;
count87 number := 0;
*/
set serveroutput on

declare
  cursor cemp is select to_char(hiredate,'yyyy') from emp;
  phiredate varchar2(4);

  --每年入职的员工人数:
  count80 number := 0;
  count81 number := 0;
  count82 number := 0;
  count87 number := 0;
begin
  open cemp;
  loop
    --取一个员工的入职年份
    fetch cemp into phiredate;
    --退出条件:notfound
    exit when cemp%notfound;

    --判断年份
    if phiredate = '1980' then count80:=count80+1;
      elsif phiredate = '1981' then count81:=count81+1;
      elsif phiredate = '1982' then count82:=count82+1;
      else count87:=count87+1;
    end if;
  end loop;
  close cemp;

  dbms_output.put_line('Total:'||(count80+count81+count82+count87));
  dbms_output.put_line('1980:'||count80);
  dbms_output.put_line('1981:'||count81);
  dbms_output.put_line('1982:'||count82);
  dbms_output.put_line('1987:'||count87);
end;
/
```

###### 案例二
```sql
/*
SQL语句：
select empno,sal from emp order by sal;
---> 光标 ---> 退出：1. 总额 > 5w   2. notfound

变量：1. 初始值  2. 最终得到
涨工资的人数: countEmp number := 0;
涨后的工资总额: salTotal number;
1. select sum(sal) into salTotal from emp;
2. 涨后=涨前 + sal * 0.1

练习： 人数:7   总额:50205.325
*/
set serveroutput on
declare
  cursor cemp is select empno,sal from emp order by sal;
  pempno emp.empno%type;
  psal   emp.sal%type;
  --涨工资的人数:
  countEmp number := 0;
  --涨后的工资总额:
  salTotal number;
begin
  --得到初始的工资总额
  select sum(sal) into salTotal from emp;

  open cemp;
  loop
    --1. 总额 > 5w
    exit when salTotal > 50000;
    --取一个员工
    fetch cemp into pempno,psal;
    --2. notfound
    exit when cemp%notfound;

    --涨工资
    update emp set sal=sal*1.1 where empno=pempno;
    --人数+1
    countEmp := countEmp + 1;
    --2. 涨后=涨前 + sal * 0.1
    salTotal := salTotal + psal * 0.1;

  end loop;
  close cemp;

  commit;
  dbms_output.put_line('人数:'||countEmp||'   总额:'||salTotal);

end;
/
```

## 触发器
数据库触发器是一个与表相关联、存储的PL/SQL程序.每当一个特定的数据操作语句(insert,update,delete)在指定的表上发出时,Oracle自动的执行触发器中定义的语句序列
##### 触发器类型
* 语句级触发器
在指定的操作语句操作之前或之后执行一次,不管这条语句影响了多少行
* 行级触发器
触发语句作用的每一条记录都被触发,在行级触发器中使用:old和:new伪记录变量,识别值的状态.
###### 第一个触发器
```sql
--每当成功插入新员工后，自动打印"成功插入新员工"
create trigger abcd
after insert
on emp
declare
begin
   dbms_output.put_line('成功插入新员工');
end;
/
```
##### 触发器作用
* 数据确认
* 实施复杂的安全性检查
* 做审计,跟踪表上所做的数据操作
* 数据备份和同步

##### 查询触发器、过程及函数
* select * from user_trggers;
* select * from user_source;

##### 创建触发器
create [or replace] trigger  触发器名
{before|after}
{delete|insert|update [of 列名]}
on 表名
[for each row[when(条件)]]   //行级触发 :new 触发后该行数据 :old触发前该行数据
plsal语句



###### 触发器应用一:实施复杂的安全性验证
```sql
/*
触发器应用一：实施复杂的安全性检查
禁止在非工作时间插入新员工

周末:to_char(sysdate,'day') in ('星期六','星期日')
上班前 下班后：to_number(to_char(sysdate,'hh24')) not between 9 and 17
*/
create or replace trigger securityemp
before insert
on emp
begin
  if to_char(sysdate,'day') in ('星期六','星期日','星期三') or
     to_number(to_char(sysdate,'hh24')) not between 9 and 17 then
     --禁止insert
     raise_application_error(-20001,'禁止在非工作时间插入新员工');     
  end if;

end;
/
```

###### 触发器应用二:数据确认
```sql
/*
触发器应用二： 数据的确认
涨后的工资不能少于涨前的工资
*/
create or replace trigger checksalary
before update
on emp
for each row
begin
  --if 涨后的薪水  < 涨前的薪水 then
  if :new.sal < :old.sal then
    raise_application_error(-20002,'涨后的工资不能少于涨前的工资。涨前:'||:old.sal||'  涨后:'||:new.sal);
  end if;
end;
/
```
###### 练习一 查询当前员工money1是前一名员工工资
```sql
select id ,name,money,(select money from test1 where id = t.id-1) money1 from test1 t;
```
###### 练习二 按课程id查出所有学生姓名
```sql
 select ci_id,wm_concat(stu_name) from (
 select c.ci_id,s.stu_name from pm_ci c,pm_stu s where
 instr(c.stu_ids,s.stu_id)>0)
 group by ci_id

 wm_concat 字符串链接
 instr 字符串2在字符1中的位置
```

##### 存储过程和存储函数
指存储在数据库中提供所用用户程序调用的子程序叫存储过程、存储函数

##### 创建存储过程
用create procedure命令建立存储过程
语法: create[or replace] procedure 过程名(参数列表) as plsql子程序体

###### 第一个存储过程
```sql
--打印Hello World
/*
调用存储过程：
1. exec sayHelloWorld();
2. begin
     sayHelloWorld();
     sayHelloWorld();
   end;
   /

*/
create or replace procedure sayHelloWorld
as
  --说明部分
begin
   dbms_output.put_line('Hello World');

end;
/

```
###### 执行存储过程
```sql
--方式一
exec sayHelloWorld();

--方式二
declare
begin
sayHelloWorld();
sayHelloWorld();
end;
/

```
###### 带参数的存储过程
```sql
--给指定的员工涨100，并且打印涨前和涨后的薪水
create or replace procedure raisesalary(eno in number)
as
   --定义变量保存涨前的薪水
   psal emp.sal%type;
begin
   --得到涨前的薪水
   select sal into psal from emp where empno=eno;

   --涨100
   update emp set sal=sal+100 where empno=eno;

    --要不要commit？

   dbms_output.put_line('涨前:'||psal||'   涨后:'||(psal+100));

end;
/
```

##### 存储函数
函数(Function)为一命名的存储程序,可带参数,并返回一计算值,函数和过程的结构类似,单必须有一个return子句,用于返回函数值.函数说明要指定函数名,结果值的类型,以及参数类型等

##### 建立存储函数的语法
create [or replace] function 函数名(参数列表)
return 函数值类型 as plsql子程序体;

###### 存储函数
```sql
--查询某个员工的年收入
create or replace function queryempincome(eno in number)
return number
as
   --定义变量保存月薪和奖金
   psal emp.sal%type;
   pcomm emp.comm%type;
begin
   select sal,comm into psal,pcomm from emp where empno=eno;

   --返回年收入
   return psal*12+nvl(pcomm,0);
end;
/
```

##### 过程和函数中的in和out
* 一般来讲,函数可以有一个返回值,过程没有
* 但过程和函数都可以通过out指定一个或多个输出参数
* 原则:如果只有一个返回值使用函数,否则使用过程

###### out参数
```sql
--查询某个员工的姓名 月薪 职位

/*
思考：
1. 查询某个员工的所有信息 ---> out参数太多
2. 查询某个部门中的所有员工信息 ---> 返回集合

*/
create or replace procedure queryempinfo(eno in number,
                                            pename out varchar2,
                                            psal   out number,
                                            pjob   out varchar2)
as
begin
  select ename,sal,empjob into pename,psal,pjob from emp where empno=eno;
end;
/
```

##### 声明包结构
<b>create [or replace] package</b> myPackage <b>as</b>
<b>type</b> empcurosr <b>is ref cursor</b>;
<b>procedure</b> queryEmpList(dno <b>in number</b>,empList <b>out</b> empcusor);
<b>end</b> myPackage;

###### 创建包体
<b>create [or replace] package body</b> myPackage <b>as</b>
<b>procedure </b> queryEmpList(dno <b>in number</b>,empList <b>out</b> empcurosr)<b> as</b>
<b>begin</b>
<b>open </b> emplist <b>for select </b>* <b>from</b> emp <b>where</b> deptno=dno;
<b>end </b>queryEmpList;
<b>end</b> myPackage;

###### out参数中使用光标
```sql
2. 查询某个部门中的所有员工信息 ---> 返回集合

包头
CREATE OR REPLACE PACKAGE MYPAKCAGE AS

  type empcursor is ref cursor;
  procedure queryEmpList(dno in number, empList out empcursor);

END MYPAKCAGE;


包体
CREATE OR REPLACE PACKAGE BODY MYPAKCAGE AS

  procedure queryEmpList(dno in number, empList out empcursor) AS
  BEGIN

    open empList for select * from emp where deptno=dno;

  END queryEmpList;

END MYPAKCAGE;
```

###### JDBC
```java
public class JDBCUtils {
	private static String driver = "oracle.jdbc.OracleDriver";
	private static String url = "jdbc:oracle:thin:@192.168.56.101:1521:orcl";
	private static String user = "scott";
	private static String password = "tiger";

	static{
		try {
			Class.forName(driver);
		} catch (ClassNotFoundException e) {
			throw new ExceptionInInitializerError(e);
		}
		//DriverManager.registerDriver(driver)
	}

	public static Connection getConnection(){
		try {
			return DriverManager.getConnection(url, user, password);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return null;
	}

	/*
	 * 运行Java程序
	 * java -Xms100M -Xmx200M HelloWorld
	 *
	 * 技术方向:
	 * 1. 性能调优  ---> tomcat
	 * 2. 故障诊断  ---> 死锁
	 */
	public static void release(Connection conn,Statement st,ResultSet rs){
		if(rs != null){
			try {
				rs.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}finally{
				rs = null;// ----> java GC
			}
		}
		if(st != null){
			try {
				st.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}finally{
				st = null;
			}
		}
		if(conn != null){
			try {
				conn.close();
			} catch (SQLException e) {
				e.printStackTrace();
			}finally{
				conn = null;
			}
		}
	}
}


public class TestOracle {
/*
 * create or replace procedure queryempinfo(eno in number,
                                            pename out varchar2,
                                            psal   out number,
                                            pjob   out varchar2)
 */
	@Test
	public void testProcedure(){
		//{call <procedure-name>[(<arg1>,<arg2>, ...)]}
		String sql = "{call queryempinfo(?,?,?,?)}";

		Connection conn = null;
		CallableStatement call = null;
		try {
			conn = JDBCUtils.getConnection();
			call = conn.prepareCall(sql);

			//对于in参数，赋值
			call.setInt(1, 7839);

			//对于out参数，申明
			call.registerOutParameter(2, OracleTypes.VARCHAR);
			call.registerOutParameter(3, OracleTypes.NUMBER);
			call.registerOutParameter(4, OracleTypes.VARCHAR);

			//执行
			call.execute();

			//取出结果
			String name = call.getString(2);
			double sal = call.getDouble(3);
			String job = call.getString(4);
			System.out.println(name+"\t"+sal+"\t"+job);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			JDBCUtils.release(conn, call, null);
		}
	}

/*
 * create or replace function queryempincome(eno in number)
return number
 */
	@Test
	public void testFunction(){
		//{?= call <procedure-name>[(<arg1>,<arg2>, ...)]}
		String sql = "{?=call queryempincome(?)}";

		Connection conn = null;
		CallableStatement call = null;
		try {
			conn = JDBCUtils.getConnection();
			call = conn.prepareCall(sql);

			//第一个是out参数
			call.registerOutParameter(1, OracleTypes.NUMBER);
			//第二个是in参数
			call.setInt(2, 7839);

			call.execute();

			//取出年收入
			double income = call.getDouble(1);
			System.out.println(income);
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			JDBCUtils.release(conn, call, null);
		}		
	}


	@Test
	public void testCursor(){
		String sql = "{call MYPAKCAGE.queryEmpList(?,?)}";

		Connection conn = null;
		CallableStatement call = null;
		ResultSet rs = null;
		try {
			conn = JDBCUtils.getConnection();
			call = conn.prepareCall(sql);

			//对于in参数，赋值
			call.setInt(1, 20);
			//对于out参数  申明
			call.registerOutParameter(2, OracleTypes.CURSOR);

			call.execute();

			//取出结果
			rs = ((OracleCallableStatement)call).getCursor(2);
			while(rs.next()){
				//取出一个员工
				String name = rs.getString("ename");
				double sal = rs.getDouble("sal");
				System.out.println(name+"\t"+sal);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			JDBCUtils.release(conn, call, rs);
		}
	}
}

```

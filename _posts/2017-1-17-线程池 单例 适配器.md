---
layout: post
title: 线程池 单例 适配器
tags:
- java

categories: java
description:
---


## 单例设计模式
单例设计模式：保证类在内存中只有一个对象。（私有构造器）
```java
//饿汉式
static class Singleton1{
    private static Singleton1 instance=new Singleton1();
    private Singleton1(){}
    public Singleton1 getInstance(){
        return instance;
    }
}
//懒汉式
static class Singleton2{
    private static Singleton2 instance;
    private Singleton2(){}
    public Singleton2 getInstance(){
        if(instance==null){
            instance=new Singleton2();
        }
        return instance;
    }
}
static class Singleton3{
    public static final Singleton3 instance=new Singleton3();
    private Singleton3(){}
}
```
## Runtime类
Runtime类是一个单例类
```java
Runtime r = Runtime.getRuntime();
//r.exec("shutdown -s -t 300");		//300秒后关机
 r.exec("shutdown -a");				//取消关机
```

## Timer
```java
public static void main(String[] args) throws IOException {
        Timer t=new Timer();
        Calendar c=Calendar.getInstance();
        c.set(2017,0,13,19,38,50);
        t.schedule(new MyTask(),c.getTime());
        while(true){
            System.out.println(new Date());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
}
public static class MyTask extends TimerTask{
    @Override
    public void run() {
        System.out.println("起床背单词");
    }
}
```
## 两个线程间的通信
多个线程并发执行时, 在默认情况下CPU是随机切换线程的
如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印
如果希望线程等待, 就调用wait()
如果希望唤醒等待的线程, 就调用notify();
这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用
```java
public static void main(String[] args) throws IOException, InterruptedException {
    final Printer p = new Printer();
    new Thread(){
        @Override
        public void run() {
            while(true){
                try {
                    p.print1();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }.start();
    new Thread(){
        @Override
        public void run() {
            while(true){
                try {
                    p.print2();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }.start();
}
public static class Printer{
    private int flag=1;
    public void print1() throws InterruptedException {
        synchronized(this){
            if(flag!=1){
                this.wait();
            }
            System.out.print("宝");
            System.out.print("塔");
            System.out.print("镇");
            System.out.print("河");
            System.out.print("妖");
            System.out.println();
            flag=2;
            this.notify();
        }
    }
    public void print2() throws InterruptedException {
        synchronized(this){
            if(flag!=2){
                this.wait();
            }
            System.out.print("小");
            System.out.print("鸡");
            System.out.print("炖");
            System.out.print("蘑");
            System.out.print("菇");
            System.out.println();
            flag=1;
            this.notify();
        }
    }
}
```

## 互斥锁ReentrantLock
lock()和unlock()方法进行同步
使用ReentrantLock类的newCondition()方法可以获取Condition对象
需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法
```java
public static void main(String[] args) throws IOException, InterruptedException {
    final Printer p=new Printer();
    new Thread(){
        @Override
        public void run() {
            try {
                while(true)
                p.print1();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }.start();
    new Thread(){
        @Override
        public void run() {
            try {
                while(true)
                p.print2();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }.start();
    new Thread(){
        @Override
        public void run() {
            try {
                while(true)
                p.print3();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }.start();
}
public static class Printer{
    private int flag=1;
    private ReentrantLock reentrantLock=new ReentrantLock();
    private Condition condition1=reentrantLock.newCondition();
    private Condition condition2=reentrantLock.newCondition();
    private Condition condition3=reentrantLock.newCondition();
    public void print1() throws InterruptedException {
        reentrantLock.lock();
        if(flag!=1){
            condition1.await();
        }
        System.out.print("1");
        System.out.print("1");
        System.out.print("1");
        System.out.println();
        flag=2;
        condition2.signal();
        reentrantLock.unlock();
    }
    public void print2() throws InterruptedException {
        reentrantLock.lock();
        if(flag!=2){
            condition2.await();
        }
        System.out.print("2");
        System.out.print("2");
        System.out.print("2");
        System.out.println();
        flag=3;
        condition3.signal();
        reentrantLock.unlock();
    }
    public void print3() throws InterruptedException {
        reentrantLock.lock();
        if(flag!=3){
            condition3.await();
        }
        System.out.print("3");
        System.out.print("3");
        System.out.print("3");
        System.out.println();
        flag=1;
        condition1.signal();
        reentrantLock.unlock();
    }
}
```


## 线程组
Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。
默认情况下，所有的线程都属于主线程组。
```java
ThreadGroup tg=new ThreadGroup("我是一个新线程组");
MyRunnable mr=new MyRunnable();
Thread t1=new Thread(tg,mr,"线程甲");
Thread t2=new Thread(tg,mr,"线程乙");
System.out.println(t1.getThreadGroup().getName());
System.out.println(t2.getThreadGroup().getName());
```
## 线程的五种状态
 新建,就绪,运行,阻塞,死亡

## 线程池的概述和使用
程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。
###### JDK5新增了一个Executors工厂类来产生线程池
```java
public static void main(String[] args) throws IOException, InterruptedException {
    ExecutorService pool=Executors.newFixedThreadPool(2);
    pool.submit(new MyRunnable());
    pool.submit(new MyRunnable());
    pool.submit(new MyRunnable());
    pool.shutdown();
}
public static class MyRunnable implements Runnable{

    @Override
    public void run() {
        for(int i=0;i<1000;i++){
            System.out.println(Thread.currentThread().getName()+" "+i);
        }
    }
}
```
######  提交的是Callable
```java
public static void main(String[] args) throws IOException, InterruptedException, ExecutionException {
    ExecutorService pool=Executors.newFixedThreadPool(2);
    Future<Integer>future1=pool.submit(new MyCallable(50));
    Future<Integer>future2=pool.submit(new MyCallable(100));
    System.out.println(future1.get());
    System.out.println(future2.get());


}
public static class MyCallable implements Callable<Integer>{
    private int num=0;
    public MyCallable(int num){
        this.num=num;
    }

    @Override
    public Integer call() throws Exception {
        int result=0;
        for(int i=0;i<=num;i++){
            result+=i;
        }
        return result;
    }
}
```



## 简单工厂模式
明确了各个类的职责
缺点有新的对象增加，就需要不断的修改工厂类，不利于后期的维护
```java
public static class AnimalFactory{
    public static Animal createAnimal(String name){
        if("dog".equals(name)){
            return new Dog();
        }else if("cat".equals(name)){
            return new Cat();
        }else {
            return null;
        }
    }
}
```
##  工厂方法模式
```java
public  interface Factory{
    Animal createAnimal();
}
public  class DogFactory implements Factory{

    @Override
    public Animal createAnimal() {
        return new Dog();
    }
}
```



## GUI
Graphical User Interface(图形用户接口)。
FlowLayout 从左到右的顺序排列。
BorderLayout 东，南，西，北，中
GridLayout 网格布局管理器
CardLayout 卡片布局管理器 选项卡
GridBagLayout网格包布局管理器
```java
    Frame frame=new Frame();
    frame.setSize(400,600);
    frame.setLocation(500,50);
    frame.setIconImage(Toolkit.getDefaultToolkit().createImage("qq.png"));
    Button b1=new Button("按钮一");
    Button b2=new Button("按钮二");
    b1.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseReleased(MouseEvent e) {
            System.exit(0);
        }
    });
    b1.addKeyListener(new KeyAdapter() {
        @Override
        public void keyReleased(KeyEvent e) {
            if(e.getKeyCode()==KeyEvent.VK_SPACE){
                System.exit(0);
            }
        }
    });
    b2.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    frame.add(b1);
    frame.add(b2);
    frame.addWindowListener(new WindowAdapter() {
        @Override
        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
    frame.setLayout(new FlowLayout());
    frame.setVisible(true);
}
```

## 适配器设计
实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.
```java
public interface Listener{
    void fun1();
    void fun2();
}
public abstract class Adapter implements Listener{
    public void fun1(){};
    public void fun2(){};
}
```

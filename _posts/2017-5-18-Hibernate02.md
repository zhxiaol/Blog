---
layout: post
title: hibernate对象状态,一级缓存和多表关联
tags:
- java

categories: java
description: hibernate对象状态,一级缓存和多表关联
---
## 对象状态
1. 瞬时状态|临时态
> 1.没有于Hibernate产生关联 2.与数据的记录没有产生关联(有关联就是与数据库id有对应)
2. 持久态
> 1.于Hibernate有关联，2.与数据库有关联(对象有id对应)
3. 游离态|托管态
> 1.与Hibernate没有关联 2.跟数据库有关联(曾经是持久态)

对象状态特点
2. session.evict(obj) 移除对象和数据库的关联
2. Hibernate会自动将持久化状态对象的变化同步到数据库中
2. 持久态的id是不允许修改的
```java
@Test
public void fun1(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u=new User();//瞬时态
    u.setName("大黄蜂");//瞬时态
    u.setPassword("12345");//瞬时态
    session.save(u);//持久态
    ts.commit();//持久态
    session.close();
    //游离态

}
//瞬时==》持久
@Test
public void fun2(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u=new User();
    u.setName("柯镇恶");
    u.setPassword("4567");
    /***
     * save方法会使用主键生成策略，为User指定id,插入数据 打印insert语句
     * 如果是incrment的策略 会打印select max(id) from  语句
     * 如果是assigned 报错,save方法之前要手动指定id
     */

    session.save(u);

    ts.commit();
    session.close();
}
//瞬时==>游离
//瞬时：没有关联，没有id
//游离:没有关联，有id
@Test
public void fun3(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u=new User();
    u.setId(2);
    ts.commit();
}
//持久==>瞬时
//持久:有关联，有id
//瞬时:无关联，无id
public void fun4(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User user = (User) session.get(User.class, 2);
    session.close();
    user.setId(null);
}
//持久==>瞬时
//持久:有关联，有id
//瞬时:无关联，无id
public void fun5(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User user = (User) session.get(User.class, 2);
    session.evict(user);
    user.setId(null);
    session.save(user);
    ts.commit();
    session.close();
}
//持久==》游离
//持久:有关联，有ID
//游离:无管理，无ID
public void fun6(){
    Session session = HibernateUtils.openSession();
    User u = (User) session.get(User.class, 2);
    session.evict(u);
}
//游离==》瞬时
public void fun7(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u = (User) session.get(User.class, 2);
    u.setId(null);
    ts.commit();
    session.close();
}
//游离==>持久
public void fun8(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u = (User) session.get(User.class, 2);
    session.evict(u);
    session.update(u);
    ts.commit();
    session.close();
}
public void fun9(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User user = (User) session.get(User.class, 2);
    user.setName("自动同步");//
    ts.commit();
    session.close();
}
```
## 一级缓存
缓存:Hibernate中野村缓存，Hibernate中存在的缓存也是用来提高效率的
Hibernate中存在两种缓存
1.线程级别缓存 session缓存
2.进程级别的缓存 Hibernate 二级缓存
session缓存：就是session对象中存在的缓存，缓存中存在的持久化状态 map<Serializable,Object>
快照:get方法。数据库取得数据时一式两份 缓存和快照 将缓存返回 当update时候比对快照是否做了修改。如果自己创建的对象， 没有快照 close的时候执行update语句更新
持久化状态:本质就是存在缓存中的对象，就是持久化状态。
```java
public void fun1(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u1 = (User) session.get(User.class, 2);
    User u2 = (User) session.get(User.class, 2);//再次查找不会执行语句，会从缓存中查找
    User u3 = (User) session.get(User.class, 2);
    System.out.println(u1==u2);
    System.out.println(u1==u3);
    session.getTransaction().commit();
    session.close();
}
@Test
public void fun2(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u1 = (User) session.get(User.class, 2);
    session.update(u1);
    ts.commit();
    session.close();
}
@Test
public void fun3(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User u1 = new User();
    u1.setId(2);
    u1.setName("擎天柱");
    u1.setPassword("1234");
    session.update(u1);
    ts.commit();
    session.close();
}
public void fun4(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    User user = (User) session.get(User.class, 2);
    user.setName("张三");
    session.update(user);
    user.setName("李四");
    session.update(user);
    user.setName("赵六");
    session.update(user);
    ts.commit();
    session.close();
}
```
#### 一级缓存细节
1. HQL语句批量查询时，查询结果是否进入缓存，再次查询会比对缓存对象是否需要封装成对象
1. SQL查询 如果把查询结果封装到对象中，放入缓存结果了
1. criterira 会将查询结果放入一级缓存，再次查询会比对缓存对象是否需要封装成对象
```java
//HQL语句批量查询时，查询结果是否进入缓存，不会使用一级缓存
@Test
public void fun2(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    List<User> list1 = session.createQuery("from User").list();
    List<User> list2 = session.createQuery("from User").list();
    List<User> list3 = session.createQuery("from User").list();
    ts.commit();
    session.close();
}
//HQL语句批量查询时，查询结果是否进入缓存 结果会放入缓存中
//HQL查询是否会使用一级缓存,HQL不会使用一级缓存
@Test
public void fun3(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    List<User> list1 = session.createQuery("from User").list();
    User user = (User) session.get(User.class, 2);
    ts.commit();
    session.close();
}
//SQL查询 如果把查询结果封装到对象中，放入缓存结果了。
@Test
public void fun4(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    List<User> list1 = session.createSQLQuery("select * from t_user").addEntity(User.class).list();
    User user = (User) session.get(User.class, 2);
    ts.commit();
    session.close();
}
//不封装成对象不会放入一级缓存
@Test
public void fun5(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    List list1 = session.createSQLQuery("select * from t_user").list();
    User user = (User) session.get(User.class, 2);
    ts.commit();
    session.close();
}
//criterira 会将查询结果放入一级缓存，但是查询不会使用一级缓存
```
## 一对多
```xml
<!--表达一对多集合-->
<set name="orders" inverse="true"><!--inverse是否将关系的维护反转给对方,true 放弃维护外键-->
    <key column="cid"></key><!--外键的值-->
    <one-to-many class="Order"/><!--对应关系-->
</set>

<many-to-one name="customer" class="Customer" column="cid"/>
```

```javascript
//Customer
public class Customer implements Serializable {
    private Integer cid;
    private String name;
    private Set<Order> orders=new HashSet<>();
}
//Customer.hbm.xml
<hibernate-mapping package="com.itheima.domain">
    <class name="Customer" table="t_customer" dynamic-insert="true" dynamic-update="true">
        <id name="cid" column="cid" type="int">
            <generator class="native"></generator>
        </id>
        <property name="name" column="name" type="string"></property>
        <!--表达一对多集合-->
        <set name="orders" inverse="true"><!--inverse是否将关系的维护反转给对方,true 放弃维护外键-->
            <key column="cid"></key><!--外键的值-->
            <one-to-many class="Order"/><!--对应关系-->
        </set>
    </class>
</hibernate-mapping>


//Order.java
public class Order {
    private Integer id;
    private String name;
    private Customer customer=new Customer();
}


//Order.hbm.xml
<hibernate-mapping package="com.itheima.domain">
    <class name="Order" table="t_order">
        <id name="id" column="id" type="int">
            <generator class="native" />
        </id>
        <property name="name" column="name" type="string"/>
        <many-to-one name="customer" class="Customer" column="cid"/>
    </class>
</hibernate-mapping>


//demo1.java
public class Demo1 {
    //指定关系游其中一方来维护，另一方不维护，有外键的一方来维护
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c=new Customer();
        c.setName("tom");
        Order o1=new Order();
        o1.setName("肥皂");
        Order o2=new Order();
        o2.setName("蜡烛");
//        c.getOrders().add(o1);//维护关系
//        c.getOrders().add(o2);//维护关系
        o1.setCustomer(c);//维护关系
        o2.setCustomer(c);//维护关系
        session.save(c);
        session.save(o1);
        session.save(o2);
        ts.commit();
        session.close();
    }
    //删除用户时，会先移除Customer中引用的外键，然后再删除customer
    //维护一方的对象,会自动维护另一方的关系
    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 2);
        if(c!=null) {
            Set<Order> orders = c.getOrders();
            for (Order o : orders) {
                o.setCustomer(null);
            }
            session.delete(c);
            ts.commit();
            session.close();
        }
    }
}
```

```html
表达一对多关系
	|
	|--Bean.hbm.xml
			|
			|--<set></set>标签
				 |
				 |--name:关系的字段名
				 |--inverse:是否放弃维护外键
				 |--cascade:
				 |		|
				 |		|--save-update:级联保存和修改
				 |		|--delete:级联删除
				 |		|--delete-orphan:孤儿删除 当没有任何外键引用Order时，Order 会被删除
				 |		|--all:save-update和delete整合
				 |		|--all-delete-orphan:save-update,delete和delete-orphan整合
				 |
				 |
				 |--<key></key>标签
				 |		|
				 |	  	|--cloumn:外键字段
				 |
				 |--<one-to-many/>一对多关系
				 		|
				 		|--class:对应的javaBean
```
```java
//Demo2.java
 //增
    //我们希望在保存Customer时,自动将未保存的Orders当中的Order保存
    //cascade: save-update
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c=new Customer();
        c.setName("tom");
        Order o1=new Order();
        o1.setName("肥皂");
        Order o2=new Order();
        o2.setName("蜡烛");
        c.getOrders().add(o1);
        c.getOrders().add(o2);
//        o1.setCustomer(c);//维护关系
//        o2.setCustomer(c);//维护关系
        session.save(c);
        ts.commit();
        session.close();
    }

    //增
    //我们希望在保存Customer时,自动将未保存的Orders当中的Order保存
    //cascade: save-update
    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 3);
        if(c!=null){
            Set<Order> orders = c.getOrders();
            for(Order o:orders){
                o.setName("哇哈哈");
            }
        }
        ts.commit();//因为设置级联修改,自动将订单的修改保存到数据
        session.close();
    }

    //cascade: delete
    //删除Customer时 ,会将Customer下的订单一并删除
    //inverse : false   6条sql语句
    //inverse : true    5条sql语句 比上面少一条维护外键
    @Test
    public void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 8);
        session.delete(c);
        ts.commit();
        session.close();
    }

    /**
     * cascade:delete
     * 操作的两方值都为delete
     * 需要注意:千万不要在两方都配置级删除，删除任何一方，会导致整个关系链对象全部删除
     */
    @Test
    public void fun4(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Order o = (Order) session.get(Order.class, 13);
        session.delete(o);//delete删除当前order
                          //找到所有关联的Customer 删除
                          //删除Customer会删除关联的所有的order再删除Customer
        ts.commit();
        session.close();
    }

//demo3.java
public class Demo3 {
    //cascade:delete-orphan 孤儿删除 当没有任何外键引用Order时，Order 会被删除
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 12);
        Iterator<Order> it = c.getOrders().iterator();//获得所有用户下的订单,将订单移出集合 维护关系
        while (it.hasNext()){
            it.next();
            it.remove();
        }
        ts.commit();
        session.close();
    }
}

//Demo4.java
public class Demo4 {
    @Test
    //cascade:all-delete-orhan=save-update+delete+delete-orphan
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c=new Customer();
        c.setName("tom");
        Order o1=new Order();
        o1.setName("肥皂");
        Order o2=new Order();
        o2.setName("蜡烛");
        c.getOrders().add(o1);
        c.getOrders().add(o2);
        session.save(c);
        ts.commit();
        session.close();
    }

    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 14);
        session.delete(c);
        ts.commit();
        session.close();
    }

    @Test
    public void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 15);
        Iterator<Order> it = c.getOrders().iterator();
        while (it.hasNext()){
            it.next();
            it.remove();
        }
        ts.commit();
        session.close();
    }
}
```

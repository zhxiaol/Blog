---
layout: post
title: 反射 枚举 jdk7-8特性
tags:
- java

categories: java
description:
---
## 类的加载概述和加载时机
当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。
##### 加载
就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。
##### 连接
验证 是否有正确的内部结构，并和其他类协调一致
准备 负责为类的静态成员分配内存，并设置默认初始化值
解析 将类的二进制数据中的符号引用替换为直接引用
##### 初始化
初始化代码块,属性默认值
##### 加载时机
创建类的实例
访问类的静态变量，或者为静态变量赋值
调用类的静态方法
使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
初始化某个类的子类
直接使用java.exe命令来运行某个主类

## 类加载器的概述和分类
##### 类加载器:
负责将.class文件加载到内存中，并为之生成对应的Class对象
##### 类加载器的分类
Bootstrap ClassLoader 根类加载器
Extension ClassLoader 扩展类加载器
Sysetm ClassLoader 系统类加载器
类加载器的作用
Bootstrap ClassLoader 根类加载器
也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中
Extension ClassLoader 扩展类加载器
负责JRE的扩展目录中jar包的加载。
在JDK中JRE的lib目录下ext目录
Sysetm ClassLoader 系统类加载器
负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径

## 反射概述
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
要想解剖一个类,必须先要获取到该类的字节码文件对象。
而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。

Person.java == 编译 == Person.class == 创建实列 == Person p=new Person()
Class.forname() =====  Person.class ===========  p.getClass()


## 读取配置文件
```java
BufferedReader br=new BufferedReader(new FileReader("config.properties"));
Class clazz=Class.forName(br.readLine());
Fruit f= (Fruit) clazz.newInstance();
Juicer j = new Juicer();
j.run(f);
```
##  Constructor
Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance("张三",20)方法创建对象
```java
Class clazz=Class.forName("com.heima.bean.Person");
Constructor c=clazz.getConstructor(String.class,int.class);
Person p= (Person) c.newInstance("张三",23);
System.out.println(p);
```


##  Field
Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField("name")方法获取,通过set(obj, "李四")方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值
```java
Class clazz=Class.forName("com.heima.bean.Person");
Constructor c=clazz.getConstructor(String.class,int.class);
Person p= (Person) c.newInstance("张三",23);
Field field=clazz.getDeclaredField("name");
field.setAccessible(true);
field.set(p,"李四");
System.out.println(p);
```

## Method
Class.getMethod(String, Class...) 和 Class.getDeclaredMethod(String, Class...)方法可以获取类中的指定方法,调用invoke(Object, Object...)可以调用该方法,Class.getMethod("eat") invoke(obj) Class.getMethod("eat",int.class) invoke(obj,10)
```java
Class clazz=Class.forName("com.heima.bean.Person");
Constructor c=clazz.getDeclaredConstructor(String.class,int.class);
Person p= (Person) c.newInstance("张三",23);
Method m1=clazz.getDeclaredMethod("eat");
m1.setAccessible(true);
m1.invoke(p);
Method m2=clazz.getDeclaredMethod("eat",int.class);
m2.setAccessible(true);
m2.invoke(p,10);
```

## 通过反射越过泛型检查
```java
ArrayList<Integer>list=new ArrayList<>();
list.add(11);
Class clazz = list.getClass();
Method m = clazz.getDeclaredMethod("add", Object.class);
m.invoke(list,"跳过泛型检测");
System.out.println(list);
```

###### 通过反射写一个通用的设置某个对象的某个属性为指定的值
```java
public static void setProperty(Object obj,String propertyName,Object value)throws Exception{
    Class clazz=obj.getClass();
    Field f=clazz.getDeclaredField(propertyName);
    f.setAccessible(true);
    f.set(obj,value);
}
```



## 动态代理的概述
* A:动态代理概述
在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象
最终会调用InvocationHandler的方法
InvocationHandler Object invoke(Object proxy,Method method,Object[] args)
```java
public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
    User user=new UserImpl();
    User u= (User) Proxy.newProxyInstance(user.getClass().getClassLoader(),user.getClass().getInterfaces(),
            new MyInvocationHandler(user));
    u.delete();
}
public static interface User{
    void delete();
}
public static class UserImpl implements User{
    @Override
    public void delete() {
        System.out.println("删除");
    }
}
public static class MyInvocationHandler implements InvocationHandler{
    private Object target;
    public MyInvocationHandler(Object target){
        this.target=target;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("权限校验");
        method.invoke(target,args);
        System.out.println("日志记录");
        return null;
    }
}
```


## 模版(Template)设计模式
模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现
```java
public static void main(String[] args) throws ClassNotFoundException, IOException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {
    new Template(){
        @Override
        public void code() {
            int i=0;
            while(i<100000){
                System.out.println(i++);
            }
        }
    }.getTime();
}
public static abstract class Template{
    public void getTime(){
        long start=System.currentTimeMillis();
        code();
        long end=System.currentTimeMillis();
        System.out.println(end-start);
    }
    public abstract void code();
}
```

## 枚举
是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。
* 定义枚举类要用关键字enum
* 所有枚举类都是Enum的子类
* 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略
* 枚举类可以有构造器，但必须是private的，它默认的也是private的。
* 枚举类也可以有抽象方法，但是枚举项必须重写该方法
* 枚举在switch语句中的使用
```java
public static void main(String[] args) {
Week mon=Week.valueOf("MON");
mon.show();
System.out.println("=================");
Week[] weeks = Week.values();
for(Week w:weeks){
    System.out.println(w.toString());
    w.show();
    System.out.println("编号是 "+w.ordinal());
}
}
public static enum Week{
    MON("星期一"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    },THU("星期二"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    },WED("星期三"){
        @Override
        public void show() {
            System.out.println(this.name);
        }
    };
    private Week(String name){
        this.name=name;
    }
    public String name;
    public abstract void show();
}
```

## JDK7新特性
* A:二进制字面量
* B:数字字面量可以出现下划线
* C:switch 语句可以用字符串
* D:泛型简化,菱形泛型
* E:异常的多个catch合并,每个异常用或|
* F:try-with-resources 语句
```java
System.out.println(0b110);//二进制字面值
System.out.println(100_000);//数字字面量可以出现下划线
switch ("str"){             //可以用字符串
    case "123":
        break;
}
ArrayList<String> list = new ArrayList<>();//菱形泛型
//多个catch 合并 每个异常用|
try {

}catch (IllegalArgumentException | IndexOutOfBoundsException ex){

}
//try-with-resources 语句
try(
        ByteOutputStream bos=new ByteOutputStream();
){

}
```

## JDK8的新特性
* 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰
* 如果是静态的就不用了
```java
interface  Inner{
    public default void print(){
        System.out.println("非静态方法要用default");
    }
    public static void method(){
        System.out.println("静态方法可以不用default");
    }
}
class Demo implements Inner{
    public void run(){
        int num=10;
        class Inner{
            public void fun(){
                System.out.println(num+"num不需要加final 会自动加");
            }
        }
        Inner i = new Inner();
        i.fun();
    }
}
```


###### 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?
因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用

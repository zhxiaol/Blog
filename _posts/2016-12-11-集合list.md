---
layout: post
title: 集合
tags:
- java

categories: java
description:
---
## 为了画个流程图又填了一天的坑。结果在github上还无法显示


```{mermaid}
graph TB

         stat["开始"]-->d  
         subgraph 方法区
         d["Demo.class"]-->m
         s["Student.class"]
         end

         subgraph 堆
         arr["arr数组<br>位置0<br>位置1<br>位置2<br>位置3<br>位置4"]
         s1["new Student"]---s
         arr-->|arr0|s1
         end

         subgraph 栈
         subgraph Main方法
         m["Main方法"]-->|进栈|m1
         m1["Student[]arr=new Student[5]"]  --> arr
         m1-->m2
         m2["arr[0]=new Student()"]
         m2-->arr
         end
         end
```

## 继承体系图
```{mermaid}
graph TB
   Collection---|有序 可以存重复的值|List
   Collection---|无序 不可以存重复的值|Set
   List---ArrayList
   List---LinkedList
   List---Vector
   Set---HashSet
   Set---TreeSet
```

## 迭代器
整个集合体系的遍历方式都是hasNext()和next()方法
###### 如果想在遍历的过程中添加元素,可以用ListIterator中的add方法
```java
ListIterator lit = list.listIterator();		
while(lit.hasNext()) {
  String str = (String)lit.next();
  if(str.equals("world")) {
    lit.add("javaee");
  }
}
```

######  Vector迭代
```java
Vector v = new Vector();			
Enumeration en = v.elements();			//获取枚举
while(en.hasMoreElements()) {			//判断是否有元素
  System.out.println(en.nextElement());//获取元素
}
```

## 数组结构和链表结构
* 数组
有下标查询快修改快
增删中间位置的整体下标都会变 增删慢
* 链表
像自行车链子，每个元素会存储它前面的地址和后面的地址
所以增删快，查询修改需要从两端开始迭代，所以慢

## List的三个子类的特点
ArrayList:
  底层数据结构是数组，查询快，增删慢。
  线程不安全，效率高。
Vector:
  底层数据结构是数组，查询快，增删慢。
  线程安全，效率低。
LinkedList:
  底层数据结构是链表，查询慢，增删快。
  线程不安全，效率高。

## contain(Object obj)和remove(Object obj)
依赖的都是equals()方法。

## ArratList三种删除方式的区别
```java
        //普通删除 索引要--
        for(int i=0;i<list.size();i++){
            if("b".equals(list.get(i))){
                list.remove(i--);
            }
        }
        Iterator<String> it = list.iterator();
        //迭代器删除，不能用集合删除的方法，因为迭代过程中如果修改会造成并发修改异常
        while (it.hasNext()){
            if("b".equals(it.next())){
                it.remove();
            }
        }
        //foreach不能增删
        for(String s:list){
            if("b".equals(s)){
                list.remove("b");
            }
        }

```

## 可变参数
只能出现在参数列表的最后
编译器为该可变参数隐含创建一个数组
```java
public static void print(int ...arr){
     for(int i=0;i<arr.length;i++){
         System.out.print(arr[i]+"  ");
     }
 }
```

## 泛型
好处：提高安全性(将运行期的错误转换到编译期)
省去强转的麻烦
必须是引用数据类型


|     |    |
| :------------- | :------------- |
| 泛型通配符<>      | 任意类型      |
| ? extends E      | 向下限定，E及其子类    |
| ? super E     | 向上限定，E及其父类    |

## Arrays工具类的asList()方法
只能修改值不能改变长度

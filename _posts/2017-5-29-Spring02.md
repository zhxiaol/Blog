---
layout: post
title: Spring AOP JDBCTemplate
tags:
- java

categories: java
description:Spring AOP JDBCTemplate
---
## AOP介绍
> 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
> AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码
> 经典应用：事务管理、性能监视、安全检查、缓存 、日志等
> pring AOP使用纯Java实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码
> AspectJ是一个基于Java语言的AOP框架，Spring2.0开始，Spring AOP引入对Aspect的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入


## AOP实现原理
> aop底层将采用代理机制进行实现。
> 接口 + 实现类 ：spring采用 jdk 的动态代理Proxy。
> 实现类：spring 采用 cglib字节码增强。

## AOP术语
1.target：目标类，需要被代理的类。例如：UserService
2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法
3.PointCut 切入点：已经被增强的连接点。例如：addUser()
4.advice 通知/增强，增强代码。例如：after、before
5. Weaving(织入):是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程.
6.proxy 代理类
7. Aspect(切面): 是切入点pointcut和通知advice的结合
	一个线是一个特殊的面。
	一个切入点和一个通知，组成成一个特殊的面。



## 手动方式
##### JDK动态代理
JDK动态代理 对“装饰者”设计模式 简化。使用前提：必须有接口
1.目标类：接口 + 实现类
2.切面类：用于存通知 MyAspect
3.工厂类：编写工厂生成代理
4.测试

```
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

public class UserServiceImpl implements UserService {

    @Override
    public void addUser() {
        System.out.println("a_proxy.a_jdk addUser");
    }

    @Override
    public void updateUser() {
        System.out.println("a_proxy.a_jdk updateUser");
    }

    @Override
    public void deleteUser() {
        System.out.println("a_proxy.a_jdk deleteUser");
    }
}

public class MyAspect {
    public void before(){
        System.out.println("前方法");
    }
    public void alter(){
        System.out.println("后方法");
    }
}

public class MyBeanFactory {
    public static UserService createService(){
        UserService userService=new UserServiceImpl();
        MyAspect myAspect = new MyAspect();
        return (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        myAspect.before();
                        Object obj = method.invoke(userService);
                        myAspect.alter();
                        return obj;
                    }
                });
    }
}


public class TestJDK {
    @Test
    public void demo01(){
        UserService service = MyBeanFactory.createService();
        service.addUser();
        service.updateUser();
        service.deleteUser();
    }
}

```



## CGLIB字节码增强
> 没有接口，只有实现类。
> 采用字节码增强框架 cglib，在运行时 创建目标类的子类，从而对目标类进行增强。
> 导入jar包：
	自己导包（了解）：
		核心：hibernate-distribution-3.6.10.Final\lib\bytecode\cglib\cglib-2.2.jar
		依赖：struts-2.3.15.3\apps\struts2-blank\WEB-INF\lib\asm-3.3.jar
	spring-core..jar 已经整合以上两个内容

```
public class UserServiceImpl  {

    public void addUser() {
        System.out.println("a_proxy.b_cglib addUser");
    }

    public void updateUser() {
        System.out.println("a_proxy.b_cglib updateUser");
    }

    public void deleteUser() {
        System.out.println("a_proxy.b_cglib deleteUser");
    }
}

public class MyAspect {
    public void before(){
        System.out.println("前方法");
    }
    public void alter(){
        System.out.println("后方法");
    }
}


public class MyBeanFactory {
    public static UserServiceImpl createService(){
        UserServiceImpl userService=new UserServiceImpl();
        MyAspect myAspect = new MyAspect();
        Enhancer enhancer=new Enhancer();
        enhancer.setSuperclass(userService.getClass());
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                myAspect.before();
                Object obj = method.invoke(userService, args);
                methodProxy.invokeSuper(proxy,args);
                myAspect.alter();
                return obj;
            }
        });
        UserServiceImpl proxyService= (UserServiceImpl) enhancer.create();
        return proxyService;
    }
}

public class TestCglib {
    @Test
    public void demo01(){
        UserServiceImpl service = MyBeanFactory.createService();
        service.addUser();
        service.updateUser();
        service.deleteUser();
    }
}
```




##	AOP联盟通知类型
> AOP联盟为通知Advice定义了org.aopalliance.aop.Advice
> Spring按照通知Advice在目标类方法的连接点位置，可以分为5类
> 前置通知 org.springframework.aop.MethodBeforeAdvice
> 在目标方法执行前实施增强
> 后置通知 org.springframework.aop.AfterReturningAdvice
> 在目标方法执行后实施增强
> 环绕通知 org.aopalliance.intercept.MethodInterceptor
> 异常抛出通知 org.springframework.aop.ThrowsAdvice
> 在方法抛出异常后实施增强
> 引介通知 org.springframework.aop.IntroductionInterceptor
> 在目标类中添加一些新的方法和属性

```
环绕通知，必须手动执行目标方法
try{
   //前置通知
   //执行目标方法
   //后置通知
} catch(){
   //抛出异常通知
}
```

## spring编写代理:半自动
1. 让spring 创建代理对象，从spring容器中手动的获取代理对象。
2. 导入jar包：
	核心：4+1
	AOP：AOP联盟（规范）、spring-aop （实现）


```
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("b_factory_bean addUser");
    }
    @Override
    public void updateUser() {
        System.out.println("b_factory_bean updateUser");
    }
    @Override
    public void deleteUser() {
        System.out.println("b_factory_bean deleteUser");
    }
}

public class MyAspect implements MethodInterceptor{
    public void before(){
        System.out.println("前方法");
    }
    public void alter(){
        System.out.println("后方法");
    }

    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        System.out.println("前");
        Object obj = mi.proceed();
        System.out.println("后");
        return obj;
    }
}

//bean.xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userServiceId" class="com.itheima.b_factory_bean.UserServiceImpl"></bean>
    <bean id="myAspectId" class="com.itheima.b_factory_bean.MyAspect"></bean>
    <bean id="proxyServiceId" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="interfaces" value="com.itheima.b_factory_bean.UserService"/>
        <property name="target" ref="userServiceId"/>
        <property name="interceptorNames" value="myAspectId"/>
        <!--强制使用cglib-->
        <property name="optimize" value="true"></property>
    </bean>
</beans>

@Test
    public void demo01(){
        String xmlPath="com/itheima/b_factory_bean/beans.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
          UserService bean = (UserService) applicationContext.getBean("proxyServiceId");
          bean.addUser();
          bean.updateUser();
          bean.deleteUser();
    }

```


## spring aop编程：全自动
> 从spring容器获得目标类，如果配置aop，spring将自动生成代理。
> 要确定目标类，aspectj 切入点表达式，导入jar包
	spring-framework-3.0.2.RELEASE-dependencies\org.aspectj\com.springsource.org.aspectj.weaver\1.6.8.RELEASE
```
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

public class MyAspect implements MethodInterceptor{
    public void before(){
        System.out.println("前方法");
    }
    public void alter(){
        System.out.println("后方法");
    }

    @Override
    public Object invoke(MethodInvocation mi) throws Throwable {
        System.out.println("前");
        Object obj = mi.proceed();
        System.out.println("后");
        return obj;
    }
}

//bean.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       					   http://www.springframework.org/schema/beans/spring-beans.xsd
       					   http://www.springframework.org/schema/aop
       					   http://www.springframework.org/schema/aop/spring-aop.xsd">
	<!-- 1 创建目标类 -->
	<bean id="userServiceId" class="com.itheima.c_spring_aop.UserServiceImpl"></bean>
	<!-- 2 创建切面类（通知） -->
	<bean id="myAspectId" class="com.itheima.c_spring_aop.MyAspect"></bean>
	<!-- 3 aop编程
		3.1 导入命名空间
		3.2 使用 <aop:config>进行配置
				proxy-target-class="true" 声明时使用cglib代理
			<aop:pointcut> 切入点 ，从目标对象获得具体方法
			<aop:advisor> 特殊的切面，只有一个通知 和 一个切入点
				advice-ref 通知引用
				pointcut-ref 切入点引用
		3.3 切入点表达式
			execution(* com.itheima.c_spring_aop.*.*(..))
			选择方法         返回值任意   包             类名任意   方法名任意   参数任意

	-->
	<aop:config proxy-target-class="true">
		<aop:pointcut expression="execution(* com.itheima.c_spring_aop.*.*(..))" id="myPointCut"/>
		<aop:advisor advice-ref="myAspectId" pointcut-ref="myPointCut"/>
	</aop:config>
</beans>

public class TestSpringAOP {
    @Test
    public void demo01(){
        String xmlPath="com/itheima/c_spring_aop/beans.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
          UserService bean = (UserService) applicationContext.getBean("userServiceId");
          bean.addUser();
          bean.updateUser();
          bean.deleteUser();
    }
}
```

## AspectJ
> AspectJ是一个基于Java语言的AOP框架
> Spring2.0以后新增了对AspectJ切点表达式支持
> @AspectJ 是AspectJ1.5新增功能，通过JDK5注解技术，允许直接在Bean类中定义切面
新版本Spring框架，建议使用AspectJ方式来开发AOP
> 主要用途：自定义开发

##切入点表达式
### execution()  用于描述方法
```
	语法：execution(修饰符  返回值  包.类.方法名(参数) throws异常)
		修饰符，一般省略
			public		公共方法
			*			任意
		返回值，不能省略
			void			返回没有值
			String		返回值字符串
			* 			任意
		包，[省略]
			com.itheima.crm			固定包
			com.itheima.crm.*.service	crm包下面子包任意 （例如：com.itheima.crm.staff.service）
			com.itheima.crm..			crm包下面的所有子包（含自己）
			com.itheima.crm.*.service..	crm包下面任意子包，固定目录service，service目录任意包
		类，[省略]
			UserServiceImpl			指定类
			*Impl					以Impl结尾
			User*					以User开头
			*						任意
		方法名，不能省略
			addUser					固定方法
			add*						以add开头
			*Do						以Do结尾
			*						任意
		(参数)
			()						无参
			(int)						一个整型
			(int ,int)					两个
			(..)						参数任意
		throws ,可省略，一般不写。

综合1
	execution(* com.itheima.crm.*.service..*.*(..))
综合2
	<aop:pointcut expression="execution(* com.itheima.*WithCommit.*(..)) ||
                          execution(* com.itheima.*Service.*(..))" id="myPointCut"/>
2.within:匹配包或子包中的方法(了解)
	within(com.itheima.aop..*)
3.this:匹配实现接口的代理对象中的方法(了解)
	this(com.itheima.aop.user.UserDAO)
4.target:匹配实现接口的目标对象中的方法(了解)
	target(com.itheima.aop.user.UserDAO)
5.args:匹配参数格式符合标准的方法(了解)
	args(int,int)
6.bean(id)  对指定的bean所有的方法(了解)
	bean('userServiceId')

```

## AspectJ 通知类型
> aop联盟定义通知类型，具有特性接口，必须实现，从而确定方法名称。
> aspectj 通知类型，只定义类型名称。已经方法格式。
```
  个数：6种
	before:前置通知(应用：各种校验)
		在方法执行前执行，如果通知抛出异常，阻止方法运行
	afterReturning:后置通知(应用：常规数据处理)
		方法正常返回后执行，如果方法中抛出异常，通知无法执行
		必须在方法执行后才执行，所以可以获得方法的返回值。
	around:环绕通知(应用：十分强大，可以做任何事情)
		方法执行前后分别执行，可以阻止方法的执行
		必须手动执行目标方法
	afterThrowing:抛出异常通知(应用：包装异常信息)
		方法抛出异常后执行，如果方法没有抛出异常，无法执行
	after:最终通知(应用：清理现场)
		方法执行完毕后执行，无论方法中是否出现异常
环绕

try{
     //前置：before
    //手动执行目标方法
    //后置：afterRetruning
} catch(){
    //抛出异常 afterThrowing
} finally{
    //最终 after
}
```

##### 导入jar包
	4个：
	aop联盟规范
	spring aop 实现
	aspect 规范
	spring aspect 实现

## AspectJ基于xml
1.目标类：接口 + 实现
2.切面类：编写多个通知，采用aspectj 通知名称任意（方法名任意）
3.aop编程，将通知应用到目标类
4.测试

```
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("d_aspect.a_xml addUser");
    }
    @Override
    public void updateUser() {
        System.out.println("d_aspect.a_xml updateUser");
        int i=10/0;
    }
    @Override
    public void deleteUser() {
        System.out.println("d_aspect.a_xml deleteUser");
    }
}

public class MyAspect{
    //前置通知
    public void myBefore(JoinPoint joinPoint){
        System.out.println("前置通知:"+joinPoint.getSignature().getName());
    }
    //后置通知
    public void myAfterReturning(JoinPoint joinpoint,Object ret){
        System.out.println("后置通知:"+joinpoint.getSignature().getName()+",-->"+ret);
    }

    //环绕通知
    public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println("前置通知");
        Object obj = joinPoint.proceed();//手动执行目标方法
        System.out.println("后置通知");
        return obj;

    }
    //抛出异常通知
    public void myAfterThrowing(JoinPoint joinPoint,Throwable e){
        System.out.println("抛出异常通知:"+joinPoint.getSignature().getName()+",-->"+e.getMessage());
    }

    //最终通知
    public void myAfter(JoinPoint joinPoint){
        System.out.println("最终通知:"+joinPoint.getSignature().getName());
    }
}

public class TestAspectXml {
    @Test
    public void demo01(){
        String xmlPath="com/itheima/d_aspect/a_xml/beans.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
          UserService bean = (UserService) applicationContext.getBean("userServiceId");
          bean.addUser();
          bean.updateUser();
          bean.deleteUser();
    }
}

//bean.xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd"
>
    <bean id="userServiceId" class="com.itheima.d_aspect.a_xml.UserServiceImpl"></bean>
    <bean id="myAspectId" class="com.itheima.d_aspect.a_xml.MyAspect"></bean>
    <!--aop编程
        <aop:aspect>将切面类声明"切面"，从而获得通知方法
                ref:切面类的引用
        <aop:pointcut>声明一个切入点，所有的通知都可以使用
                expression 切入点你表达式
                id 名称，用于其他通知引用
    -->
    <aop:config>
        <aop:aspect ref="myAspectId">
            <aop:pointcut id="myPointcut" expression="execution(* com.itheima.d_aspect.a_xml.UserServiceImpl.*(..))"></aop:pointcut>
            <!--前置通知
                method:方法名
                pointcut:切入点表达式,此表达式当前通知使用
                pointcut-ref:切入点的引用，可以与其他通知共享通知
                通知方法可以有参数myBefore(JoinPoint joinPoint)
                参数1:org.aspectj.lang.JoinPoint 用于描述连接点(目标方法)，可以获得目标方法名等
                <aop:before method="myBefore"  pointcut-ref="myPointcut"/>
            -->

            <!--后置通知，目标方法后执行，获得返回值
                <aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut"/>
                returning:通知方法第二个参数的名称
             通知方法格式:public void myAfterReturning(JoinPoint joinpoint,Object ret)
                参数1：连接点描述
                参数2：类型Object,参数名returning配置的

                <aop:after-returning method="myAfterReturning" pointcut-ref="myPointcut" returning="ret" />
            -->

            <!--环绕通知
                <aop:around method="" pointcut-ref=""/>
                通知方法格式public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable
                返回类型:Object
                方法名:任意
                参数:org.aspectj.lang.ProceedingJoinPoint
                执行目标方法:Object obj=joinpoint.proceed(）
                例如:
                <aop:around method="myAround" pointcut-ref="myPointcut"></aop:around>
            -->

            <!--抛出异常
                <aop:after-throwing method="" pointcut-ref=""/>
                通知方法格式:public void myAfterThrowing(JoinPoint joinPoint)
                throwing:通知方法的第二个参数名称
                参数1:链接点描述对象
                参数2:获得异常信息，类型Throwable ,参数名称由throwing控制
                列如:
                <aop:after-throwing method="myAfterThrowing" pointcut-ref="myPointcut" throwing="e"/>
            -->
            <!--最终通知-->
            <aop:after method="myAfter" pointcut-ref="myPointcut"/>
        </aop:aspect>
    </aop:config>
</beans>
```

## AspectJ基于注解
```
public interface UserService {
    public void addUser();
    public String updateUser();
    public void deleteUser();
}

@Service("userServiceId")
public class UserServiceImpl implements UserService {
    @Override
    public void addUser() {
        System.out.println("d_aspect.b_anno addUser");
    }
    @Override
    public String updateUser() {
        System.out.println("d_aspect.b_anno updateUser");
        //int i=10/0;
        return "返回值";
    }
    @Override
    public void deleteUser() {
        System.out.println("d_aspect.b_anno deleteUser");
    }
}



@Component
@Aspect
public class MyAspect{
    //切入点当前有效
    //@Before("execution(* com.itheima.d_aspect.b_anno.UserServiceImpl.*(..))")
    public void myBefore(JoinPoint joinPoint){
        System.out.println("前置通知:"+joinPoint.getSignature().getName());
    }
    //声明公共的切入点
    @Pointcut("execution(* com.itheima.d_aspect.b_anno.UserServiceImpl.*(..))")
    private void myPointCut(){

    }
    //@AfterReturning(value = "myPointCut()",returning = "ret")
    public void myAfterReturning(JoinPoint joinpoint,Object ret){
        System.out.println("后置通知:"+joinpoint.getSignature().getName()+",-->"+ret);
    }

    //@Around(value="myPointCut()")
    public Object myAround(ProceedingJoinPoint joinPoint) throws Throwable{
        System.out.println("前置通知");
        Object obj = joinPoint.proceed();//手动执行目标方法
        System.out.println("后置通知");
        return obj;

    }
    //@AfterThrowing(value = "myPointCut()",throwing = "e")
    public void myAfterThrowing(JoinPoint joinPoint,Throwable e){
        System.out.println("抛出异常通知:"+joinPoint.getSignature().getName()+",-->"+e.getMessage());
    }

    @After("myPointCut()")
    public void myAfter(JoinPoint joinPoint){
        System.out.println("最终通知:"+joinPoint.getSignature().getName());
    }
}


public class TestAspectAnno {
    @Test
    public void demo01() {
        String xmlPath = "com/itheima/d_aspect/b_anno/beans.xml";
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);
        UserService bean = (UserService) applicationContext.getBean("userServiceId");
        bean.addUser();
        bean.updateUser();
        bean.deleteUser();
    }
}

//bean.xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/aop
                           http://www.springframework.org/schema/aop/spring-aop.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd">
    <!--1.扫描注解类-->
    <context:component-scan base-package="com.itheima.d_aspect.b_anno"/>
    <!--2.确定AOP注解生效-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
</beans>
```

## JdbcTemplate
> spring 提供用于操作JDBC工具类，类似：DBUtils。
> 依赖 连接池DataSource （数据源）


## 导入jar包
```
spring 4+1:
spring-beans-3.2.0.RELEASE.jar
spring-context-3.2.0.RELEASE.jar
spring-core-3.2.0.RELEASE.jar
spring-expression-3.2.0.RELEASE.jar

mysql驱动:
mysql-connector-java-5.1.7-bin.jar

jdbc和事务:
spring-jdbc-3.2.0.RELEASE.jar
spring-tx-3.2.0.RELEASE.jar

c3p0连接池:
com.springsource.com.mchange.v2.c3p0-0.9.1.2.jar

dbcp连接池:
com.springsource.org.apache.commons.dbcp-1.2.2.osgi.jar
com.springsource.org.apache.commons.pool-1.5.3.jar

```

## JDBCTemplate
###### api
```
public static void main(String[] args) {
    BasicDataSource dataSource = new BasicDataSource();
    dataSource.setDriverClassName("com.mysql.jdbc.Driver");
    dataSource.setUrl("jdbc:mysql://localhost:3306/ee19_spring_day02?characterEncoding=utf-8");
    dataSource.setUsername("root");
    dataSource.setPassword("root");
    JdbcTemplate jdbcTemplate=new JdbcTemplate();
    jdbcTemplate.setDataSource(dataSource);
    jdbcTemplate.update("insert into t_user(username,password) values(?,?)","tom",998);
}
```
###### dbcp
```
public class UserDao {
    private JdbcTemplate jdbcTemplate;
    public void update(User user){
        String sql="update t_user set username = ? ,password = ? where id = ?";
        Object[]args={user.getUsername(),user.getPassword(),user.getId()};
        jdbcTemplate.update(sql,args);
    }

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
}

public class TestDBCP {
    @Test
    public void demo1(){
        String xmlPath="com/itheima/c_dbcp/bean.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        UserDao userDao= (UserDao) applicationContext.getBean("userDaoId");
        User user = new User();
        user.setId(1);
        user.setUsername("杰克");
        user.setPassword("998");
        userDao.update(user);
    }
}

//bean.xml
<bean id="userDaoId" class="com.itheima.c_dbcp.UserDao">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"/>
</bean>
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/ee19_spring_day02?characterEncoding=utf-8"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>
```

###### C3P0
```
public class UserDao {
    private JdbcTemplate jdbcTemplate;
    public void update(User user){
        String sql="update t_user set username = ? ,password = ? where id = ?";
        Object[]args={user.getUsername(),user.getPassword(),user.getId()};
        jdbcTemplate.update(sql,args);
    }
    public List<User> findAll(){
        return jdbcTemplate.query("select * from t_user",ParameterizedBeanPropertyRowMapper.newInstance(User.class));
    }

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
}

public class TestC3P0 {
    @Test
    public void demo1(){
        String xmlPath="com/itheima/d_c3p0/bean.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        UserDao userDao= (UserDao) applicationContext.getBean("userDaoId");
        List<User> lists = userDao.findAll();
        System.out.println(lists);

    }
}
//bean.xml
<bean id="userDaoId" class="com.itheima.d_c3p0.UserDao">
    <property name="jdbcTemplate" ref="jdbcTemplate"/>
</bean>
<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <property name="dataSource" ref="dataSource"/>
</bean>
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ee19_spring_day02?characterEncoding=utf-8"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

###### jdbcDaoSupport
```
public class UserDao extends JdbcDaoSupport{
    public void update(User user){
        String sql="update t_user set username = ? ,password = ? where id = ?";
        Object[]args={user.getUsername(),user.getPassword(),user.getId()};
        this.getJdbcTemplate().update(sql,args);
    }
    public List<User> findAll(){
        return this.getJdbcTemplate().query("select * from t_user",ParameterizedBeanPropertyRowMapper.newInstance(User.class));
    }
}

public class TestJdbcDaoSupport {
    @Test
    public void demo1(){
        String xmlPath="com/itheima/e_jdbcdaosupport/bean.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        UserDao userDao= (UserDao) applicationContext.getBean("userDaoId");
        List<User> lists = userDao.findAll();
        System.out.println(lists);

    }
}

//bean.xml
<bean id="userDaoId" class="com.itheima.e_jdbcdaosupport.UserDao">
    <property name="dataSource" ref="dataSource"/>
</bean>
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ee19_spring_day02?characterEncoding=utf-8"/>
    <property name="user" value="root"/>
    <property name="password" value="root"/>
</bean>
```

###### properties
```
public class UserDao extends JdbcDaoSupport{
    public void update(User user){
        String sql="update t_user set username = ? ,password = ? where id = ?";
        Object[]args={user.getUsername(),user.getPassword(),user.getId()};
        this.getJdbcTemplate().update(sql,args);
    }
    public List<User> findAll(){
        return this.getJdbcTemplate().query("select * from t_user",ParameterizedBeanPropertyRowMapper.newInstance(User.class));
    }


    public User findUserById(int id) {
        return this.getJdbcTemplate().queryForObject("select * from t_user where id = ?",ParameterizedBeanPropertyRowMapper.newInstance(User.class),id);
    }
}

public class TestProps {
    @Test
    public void demo1(){
        String xmlPath="com/itheima/f_properties/bean.xml";
        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(xmlPath);
        UserDao userDao= (UserDao) applicationContext.getBean("userDaoId");
        User user=userDao.findUserById(1);
        System.out.println(user);

    }
}

//bean.xml
   <!-- 加载配置文件
   "classpath:"前缀表示 src下
   在配置文件之后通过  ${key} 获得内容
-->
   <context:property-placeholder location="classpath:com/itheima/f_properties/jdbcInfo.properties"/>
   <bean id="userDaoId" class="com.itheima.f_properties.UserDao"
   >
       <property name="dataSource" ref="dataSource"/>
   </bean>
   <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
       <property name="driverClass" value="${jdbc.driverClass}"></property>
       <property name="jdbcUrl" value="${jdbc.jdbcUrl}"></property>
       <property name="user" value="${jdbc.user}"></property>
       <property name="password"  value="${jdbc.password}"></property>
   </bean>
```

---
layout: post
title: hibernate 多对多关系,加载策略,查询总结和事务连接池
tags:
- java

categories: java
description:hibernate 多对多关系,加载策略,查询总结和事务连接池
---
1.1.1Hibernate的关联关系映射:(多对多)

1.1.1.1多对多的配置:

```
Bean.hbm.xml
	|
	|--<set></set>表示集合
			|
			|--name:集合的名称
			|--table:多对多中间表名
			|--<key></key>
			|		|
			|		|--column:引用我的外键名称
			|
			|--<many-to-many>
					|
					|--class:集合引用方的类型
					|--column:对方在中间表的外键名
inverse:我是否要放弃维护外键
cascade:是否需要级联操作
```
```
public class Student {
    private Integer id;
    private String name;
    private Set<Course> courses=new HashSet<>();
}


public class Course {
    private Integer id;
    private String name;
    private Set<Student>students=new HashSet<>();
}

//student.hbm.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.itheima.domain">
    <class name="Student" table="t_student">
        <id type="int" name="id" column="id">
            <generator class="native"/>
        </id>
        <property name="name" column="name" type="string"/>
        <!--多对多-->
        <!--
            set 表达集合
                name:集合的名称
                table:多对多中间表名
            key:表达外键
              column:引用我的外键
            many-to-many 表达多对多
             class:集合引用方的类型
             column:对方在中间表的外键名
        -->
        <set name="courses" table="t_student_course" inverse="false" cascade="save-update">
            <key column="sid"></key>
            <many-to-many class="Course" column="cid"/>
        </set>
    </class>
</hibernate-mapping>

//Course.hbm.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.itheima.domain">
    <class name="Course" table="t_course">
        <id type="int" name="id" column="id">
            <generator class="native"/>
        </id>
        <property name="name" column="name" type="string"/>
        <set name="students" table="t_student_course" inverse="true">
            <key column="cid"></key>
            <many-to-many class="Student" column="sid"/>
        </set>
    </class>
</hibernate-mapping>

//Hibernate.cfg.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE hibernate-configuration PUBLIC
   "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
   "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">

<hibernate-configuration>
   <session-factory >
      <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>
      <property name="hibernate.connection.username">root</property>
      <property name="hibernate.connection.password">root</property>
      <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/ee19day03?characterEncoding=utf-8</property>
      <property name="show_sql">true</property>
      <property name="format_sql">true</property>
      <property name="hbm2ddl.auto">update</property>
      <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
      <property name="hibernate.connection.autocommit">true</property>
      <property name="hibernate.current_session_context_class">thread</property>
      <mapping resource="com/itheima/domain/Student.hbm.xml"/>
      <mapping resource="com/itheima/domain/Course.hbm.xml"/>
   </session-factory>
</hibernate-configuration>

//Demo1.java
public class Demo1 {
    /**
     * 保存学生:通过学生保存课程，由学生维护外键
     * student的inverse=false;casecade=save-update
     * course的inverse=true
     */
    @Test
    public  void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Student stu1 = new Student();
        stu1.setName("tom");
        Student stu2 = new Student();
        stu2.setName("jerry");
        Course c1=new Course();
        c1.setName("Struts2");
        Course c2=new Course();
        c2.setName("Hibernate");
        Course c3=new Course();
        c3.setName("Spring");
        stu1.getCourses().add(c1);//维护关系，级联保存
        stu1.getCourses().add(c2);
        stu1.getCourses().add(c3);

        stu2.getCourses().add(c1);
        stu2.getCourses().add(c2);
        stu1.getCourses().add(c3);
        session.save(stu1);
        session.save(stu2);

        ts.commit();
        session.close();
    }
}

```

2      抓取策略（优化查询）
2.1加载方式

l  立即加载：立即查询，在执行查询语句时，立即查询所有的数据。
l  延迟加载：延迟查询，在执行查询语句之后，在需要时在查询。（懒加载）

2.2加载策略

l  类级别加载：当前的类的属性获取是否需要延迟。
l  关联级别的加载：当前类 关联 另一个类是否需要延迟。

2.3类级别加载

l  get：立即检索。get方法一执行，立即查询所有字段的数据。
l  load：延迟检索。默认情况，load方法执行后，如果只使用OID的值不进行查询，如果要使用其他属性值将查询 。 （先返回一个代理对象，使用代理对象的属性时，再加载）Customer.hbm.xml<class  lazy="true | false">
              lazy 默认值true，表示延迟检索，如果设置false表示立即检索。


```
public class Demo {
    /**
     类级别懒加载
     load方法
     class lazy属性 默认是true
     */
    @Test
    public  void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        //立即
        //Customer c = (Customer)session.get(Customer.class,1);
        //延迟
        Customer c = (Customer) session.load(Customer.class, 1);
        System.out.println(c.getName());
        System.out.println(c.getId());
        ts.commit();
        session.close();
    }
}
```



2.4关联级别懒加载

> 默认:与我关联的数据，在使用时才会加载
2.4.1  一对多或多对多

2.4.1.1介绍

&lt;set>提供两个属性
|属性|备注|
|----|------|
|fetch|确定使用sql格式|
|lazy|关联对象是否延迟|
|fetce=join|底层使用迫切左外连接|
|fetce=select|使用多个select语句（默认值）|
|fetce=subselect|使用子查询|
|lazy=false|立即|
|lazy= true |延迟（默认值）|
|lazy= extra |极其懒惰,获取size时只会select count()|

fetch和Lazy组合
|fetch|Lazy|策略|
|------|-----|------|
|join|false|采用迫切左外链接查询|
|join|true|采用迫切左外链接|
|join|extra|采用迫切左外链接|
|select|false|采用立即检索|
|select|true|采用延迟检索|
|select|extra|采用延迟检索|
|subselect|false/true/extra|嵌套子查询，Lazy决定检索策略|

```
public class Demo2 {
    /**
     关联级别懒加载
     默认:与我关联的数据，在使用时才会加载
     */
    @Test
    public  void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.load(Customer.class, 1);
        for(Order order:c.getOrders()){
            System.out.println(order);
        }

        ts.commit();
        session.close();
    }

    /**
     关联级别懒加载
     默认:与我关联的数据，在使用时才会加载
     <set></set>lazy为false 立即加载
     */
    @Test
    public  void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.load(Customer.class, 1);
        for(Order order:c.getOrders()){
            System.out.println(order);
        }

        ts.commit();
        session.close();
    }
    /**
     关联级别懒加载
     默认:与我关联的数据，在使用时才会加载
     <set></set>lazy为false 立即加载 fetch join(使用多表链接查询)
     */
    @Test
    public  void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.load(Customer.class, 1);
        for(Order order:c.getOrders()){
            System.out.println(order);
        }

        ts.commit();
        session.close();
    }
    //关联级别
    //fetch subselect
    @Test
    public void fun4(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        List<Customer> list = session.createQuery("from Customer ").list();
        for(Customer c:list){
            System.out.println(c.getOrders());
        }
        ts.commit();
        session.close();
    }

    //关联级别
    //fetch extra
    @Test
    public void fun5(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 2);
        int size = c.getOrders().size();
        System.out.println(size);
        for(Order o:c.getOrders()){
            System.out.println(o.getName());
        }
        ts.commit();
        session.close();
    }

    //关联级别
    //fetch extra fetch:subselect
    @Test
    public void fun6(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        List<Customer> list = session.createQuery("from Customer ").list();
        for(Customer c:list){
            System.out.println(c.getOrders().size());
            for(Order o:c.getOrders()){
                System.out.println(o.getName());
            }
        }
        ts.commit();
        session.close();
    }
}
```
## 多对一检索策略
many-to-one
|属性|备注|
|-----|-----|
|lazy=false|关闭懒加载|
|lazy=proxy|看客户对象的类加载策略来决定|
|lazy=no-proxy|不做研究|
|fetch=select|使用普通的select加载 |
|fetch=join|使用表连接加载数据|

fetch和Lazy组合
|fetch|Lazy|结果|
|select|false|加载订单时，立即加载客户数据,普通select语句加载客户|
|select|proxy|类加载策略lazy=false:同上|
|select|proxy|类加载策略lazy=true:加载订单时，先不加载客户数据，使用时再加载|
|join|false|使用表连接查询订单以及对应客户数据,lazy失效|
|join|proxy|使用表连接查询订单以及对应客户数据,lazy失效|

```
public class Demo3 {
    /**
     关联级别懒加载 多对一
     fetch select lazy false
     */
    @Test
    public  void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Order o = (Order) session.get(Order.class, 2);
        System.out.println(o.getCustomer().getName());
        ts.commit();
        session.close();
    }

    /**
     关联级别懒加载 多对一
     fetch select lazy proxy
     customer类加载策略是flase 同上 直接select加载客户数据
     customer类加载测试是true 先不加载客户数据 使用时再加载
     */
    @Test
    public  void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Order o = (Order) session.get(Order.class, 2);
        System.out.println(o.getCustomer().getName());
        ts.commit();
        session.close();
    }

    /**
     关联级别懒加载 多对一
     fetch join lazy false/proxy
     customer类加载策略是flase 同上 直接select加载客户数据
     customer类加载测试是true 先不加载客户数据 使用时再加载
     */
    @Test
    public  void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Order o = (Order) session.get(Order.class, 2);
        System.out.println(o.getCustomer().getName());
        ts.commit();
        session.close();
    }
}
```

## 批量查询
> batch-size="2" 决定一次加载几个集合对象的数据，使用in条件加载多个关联数据

##总结
|检索策略|有点|缺点|优先考虑使用的场合|
|-------|----|----|--------------|
|立即检索|对应用程序完全透明，不管对象处于持久化状态还是游离状态，应用程序都可以从一个对象导航到关联的对象|(1)select语句多(2)可能会加载应用程序不需要访问的对象，浪费许多内存空间。|(1)类级别(2)应用程序需要立即访问的(3)使用了二级缓存|
|延迟检索|由应用程序决定需要加载哪些对象，可以避免执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并节省内存空间|应用程序如果希望访问游离状态的代理类实例，必须保证她在持久化状态时已经被初始化。|(1)一对多或者多对多关联(2)应用程序不需要立即访问|
|表连接检索|(1)对应用程序完全透明，不管对象处于持久化状态还是游离状态，都可从一个对象导航到另一个对象。(2)使用了外连接，select语句少|(1)可能会加载应用程序不需要访问的对象，浪费内存。(2)复杂的数据库表连接也会影响检索性能。|(1)多对一或一对一关联(2)需要立即访问的对象(3)数据库有良好的表连接性能|
## 查询总结
Hibernate查询分类:
1. get/load 根据OID检索
1. 对象视图检索 c.getOrers()
1. Sql语句 createSqlQuery()
1. Hql语句 createQuery()
1. Criteria查询 createCriteria()
## HQL
> HQL(Hibernate Query Language) 对象操作查询语言 Hibernate特有
```
public class Demo1 {
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query=session.createQuery("select  c from Customer c");//添加别名
        List<Customer> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }
    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("select c.name from Customer  c");//对应属性的名称
        Query query2 = session.createQuery("select c.name ,c.id from Customer c");
        List<Object> list = query.list();
        List<Object[]> list2 = query2.list();
        System.out.println("list1:"+list);
        for(Object[] arr:list2){
            System.out.println("list2:"+Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 投影查询
     * 在选择查询基础上，想把查询结果封装到对象中
     */
    @Test
    public void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("select new Customer(c.id,c.name) from Customer  c");
        List<Customer> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }

    /**
     * 排序
     *
     */
    @Test
    public void fun4(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c order by c.id desc");
        List<Customer> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }

    /**
     * 分页
     */
    @Test
    public void fun5(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c  order by id desc ");
        //limit ?,? firstResult,maxResults
        query.setFirstResult(0);//从哪个索引开始取数据，包裹索引本身记录
        query.setMaxResults(1);//取多少条数据
        ts.commit();
        session.close();
    }
    //绑定参数
    @Test
    public void fun6(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c where c.id = ?");
        query.setInteger(0,2);//JDBC索引从1开始,Hibernate从0开始
        Customer c = (Customer) query.uniqueResult();
        System.out.println(c);

        Query query2 = session.createQuery("from Customer  c where  c.id = :haha");//给占位符取名字
        query2.setInteger("haha",2);
        Customer c2 = (Customer) query2.uniqueResult();
        System.out.println(c2);

        ts.commit();
        session.close();
    }

    //聚合函数
    @Test
    public void fun7(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("select count(*) from Customer c");
        Object  count = query.uniqueResult();
        System.out.println(count);

        Query query2 = session.createQuery("select avg(c.id) from Customer  c");
        Object avg = query2.uniqueResult();
        System.out.println(avg);

        Query query3 = session.createQuery("select min(c.id) from Customer  c");
        Object min = query3.uniqueResult();
        System.out.println(min);


        Query query4 = session.createQuery("select max(c.id) from Customer  c");
        Object max = query4.uniqueResult();
        System.out.println(max);

        ts.commit();
        session.close();
    }
    //分组 group by having
    @Test
    public void fun8(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("select o.customer,count(o) from Order o group by o.customer having o.customer.id>1");
        List<Object[]> list = query.list();
        for (Object[]arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }
}
```
## HQL表连接
```
/**
 * HQL表连接
 * 交叉连接 ==> 笛卡尔积
 * 内连接
 * 左外连接
 * 右外连接
 */
public class Demo2 {
    //笛卡尔积 开发时要避免
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c,Order o");
        List<Object[]> list = query.list();
        for(Object[] arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 内连接 隐式内连接
     * 隐式内连接：在笛卡尔积中过滤
     * 显示内连接:inner join
     */
    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer  c ,Order  o where o.customer.id=c.id");
        List<Object[]> list = query.list();
        for(Object[] arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 内连接 显示内连接
     * 隐式内连接：在笛卡尔积中过滤
     * 显示内连接:inner join
     * List<Object[]> {Customer,Oder} 将子和父分别装入数组中
     */
    @Test
    public void fun3(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer  c inner join c.orders");
        List<Object[]> list = query.list();
        for(Object[]arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 内连接 迫切显示内连接
     * 隐式内连接：在笛卡尔积中过滤
     * 显示内连接:inner join
     * list<Object> 迫切会将子装入父封装成一个对象
     */
    @Test
    public void fun4(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c inner join fetch c.orders");
        List<Object> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }

    /**
     * 左外连接
     * left [outer] join
     */
    @Test
    public void fun5(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c left outer join c.orders");
        List<Object[]> list = query.list();
        for(Object[]arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 左外连接 迫切
     * left [outer] join
     */
    @Test
    public void fun6(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c left outer join fetch c.orders");
        List<Customer> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }

    /**
     * 右外连接
     * right [outer] join
     */
    @Test
    public void fun7(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c right outer join c.orders");
        List<Object[]> list = query.list();
        for(Object[]arr:list){
            System.out.println(Arrays.toString(arr));
        }
        ts.commit();
        session.close();
    }

    /**
     * 右外连接 迫切
     * right [outer] join
     */
    @Test
    public void fun8(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.createQuery("from Customer c right outer join fetch c.orders");
        List<Customer> list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }
}
```
## HQL命名查询
> 可以在配置文件中注册SQL语句
>全局 bean.hbm.xml中配置 局部 class标签里面
```
//Customer.hbm.xml
<hibernate-mapping package="com.itheima.domain">
    <class name="Customer" table="t_customer" >
        <id name="id" column="id" type="int">
            <generator class="native"></generator>
        </id>
        <property name="name" column="name" type="string" ></property>
        <!--表达一对多集合-->
        <set name="orders" inverse="false" batch-size="2"><!--inverse是否将关系的维护反转给对方,true 放弃维护外键-->
            <key column="cid"></key><!--外键的值-->
            <one-to-many class="Order"/><!--对应关系-->
        </set>
        <!--局部配置-->
        <query name="bcd"><![CDATA[from Order]]> </query>
    </class>
    <!--全局配置-->
    <query name="abc"><![CDATA[from Customer]]> </query>
</hibernate-mapping>

public class Demo3 {
    //局部
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.getNamedQuery("com.itheima.domain.Customer.bcd");
        List list = query.list();
        System.out.println(list);
        ts.commit();
        session.close();
    }
    //全局的
    @Test
    public void fun2(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Query query = session.getNamedQuery("abc");
        System.out.println(query.list());
        ts.commit();
        session.close();
    }
}
```

## QBC查询
> Query by Criteria 面向对象查询方式
> 离线查询 一般使用在web层或者service层拼凑
```
@Test
public void fun1(){
    //service层
    DetachedCriteria dc = DetachedCriteria.forClass(Customer.class);
    dc.add(Restrictions.eq("id",1));
    //dao层
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    Criteria c = dc.getExecutableCriteria(session);
    System.out.println(c.list());
    ts.commit();
    session.close();
}
```
## 整合C3P0连接池
1. 导入c3p0 jar包   hibernate目录/optional/
1. 配置hibernate.cgf.xml  hibernate目录/product/etc/hibernate.properties中
1. 具体配置连接池属性
```
//hibernate.cfg.xml
<property name="hibernate.connection.provider_class">org.hibernate.connection.C3P0ConnectionProvider</property>
<!--#hibernate.c3p0.max_size 2-->
<!--#hibernate.c3p0.min_size 2-->
<!--#hibernate.c3p0.timeout 5000-->
<!--#hibernate.c3p0.max_statements 100-->
<!--#hibernate.c3p0.idle_test_period 3000-->
<!--#hibernate.c3p0.acquire_increment 2-->
<!--#hibernate.c3p0.validate false-->
<property name="c3p0.max_size">5</property>
<property name="c3p0.min_size">2</property>

```
## 事务
> 自动提交事务，开发中不用
> 在hibernate中设置隔离级别 &lt;property name="hibernate.connection.isolation">4

## 数据库中的锁
> 悲观锁 防止别人跟我抢着修改数据
> 乐观锁 人为控制的锁
## 悲观锁
1. 读锁/共享锁   在读取过程中，不希望别人修改，并且自己也不会修改
> select * from table lock in share mode
1. 写锁/排他锁   我不仅要读还要对数据修改，为读取的数据加上写锁
> select * from table for update
##### 在Hibernate中的悲观锁
```
//悲观锁 写锁
@Test
public void fun1(){
    Session session = HibernateUtils.openSession();
    Transaction ts = session.beginTransaction();
    Customer c = (Customer) session.get(Customer.class, 1, LockOptions.UPGRADE);
    System.out.println(c);
    ts.commit();
    session.close();
}
```


```
//乐观锁
//Customer.java
private Integer version;//javabean类添加一个版本号字段

//Customer.hbm.xml
<!--在id后面配置乐观锁版本号的属性名-->
<version name="version"/>

public class Demo3 {
    @Test
    public void fun1(){
        Session session = HibernateUtils.openSession();
        Transaction ts = session.beginTransaction();
        Customer c = (Customer) session.get(Customer.class, 1);
        c.setName("张三");//每次版本号都会加1
        ts.commit();
        session.close();
    }
}
```

---
layout: post
title: struts2参数封装,类型转换,数据验证
tags:
- java

categories: java
description: struts2参数封装,类型转换,数据验证
---
## 参数封装
###### 静态参数封装
> 静态注入是struts-default.xml中的staticparams拦截器实现的
```
//Demo1Action
public class Demo1Action extends ActionSupport {
    private String username;
    private int age;
    public String addUser(){
        System.out.println("username:"+username+" age:"+age);
        return null;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

//struts.xml
<package name="p1" extends="struts-default" >
    <action name="action1" class="com.itheima.web.action.Demo1Action" method="addUser">
        <!--默认拦截器栈defaultStatck工作，只要写了任何一个拦截器，默认全部不起作用-->
        <param name="username">张三</param>
        <param name="age">23</param>
    </action>
</package>
```
###### 动态参数封装第一种方式
> 数据模型与动作类在一起 表单中的name必须后set后面的名称一致
>是struts-default.xml中的params拦截器实现的
```
//Demo2Action
public class Demo2Action extends ActionSupport {
    private String username;
    private int age;
    public String addUser(){
        System.out.println("username:"+username+" age:"+age);
        return null;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}


//stutus.xml
<action name="action2" class="com.itheima.web.action.Demo2Action" method="addUser">
</action>


//addUser2.jsp
<form action="${pageContext.request.contextPath}/action2.action" method="post">
    用户名:<input type="text" name="username"><br/>
    年龄:<input type="text" name="age"><br/>
    <input type="submit" value="提交">
</form>
```
###### 动态参数封装第二种方式
> 先调用getUser()判断没有对象如果没有创建对象setUser(),再调用getUser().set参数
```
//User
public class User implements Serializable {
    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}


//Demo3Action
public class Demo3Action extends ActionSupport {
    private User user;
    public String addUser(){
        System.out.println(user.getUsername()+","+user.getAge());
        return null;
    }

    public User getUser() {
        System.out.println("getUser");
        return user;
    }

    public void setUser(User user) {
        System.out.println("setUser");
        this.user = user;
    }
}


//struts.xml
<action name="action3" class="com.itheima.web.action.Demo3Action" method="addUser"></action>


//addUser3.jsp
<form action="${pageContext.request.contextPath}/action3.action" method="post">
    用户名:<input type="text" name="user.username"><br/>
    年龄:<input type="text" name="user.age"><br/>
    <input type="submit" value="提交">
</form>
```
###### 动态参数封装第三种方式 模型驱动
>实现模型驱动步骤
*  1.实现一个ModelDriver的接口
*  2.实现接口中的抽象方法
*  3.在使用模型驱动的时候，数据模型必须由我们实例化
>是有一个ModelDriven的拦截器实现的
```
//Demo4Action
public class Demo4Action extends ActionSupport implements ModelDriven<User> {
    private User user=new User();//使用模型驱动，必须自己实例化
    public String addUser(){
        System.out.println(user.getUsername()+","+user.getAge());
        return null;
    }

    public User getUser() {
        System.out.println("getUser");
        return user;
    }

    public void setUser(User user) {
        System.out.println("setUser");
        this.user = user;
    }

    @Override
    public User getModel() {
        return user;
    }
}
//struts.xml
<action name="action4" class="com.itheima.web.action.Demo4Action" method="addUser"></action>

//addUser4.jsp
<form action="${pageContext.request.contextPath}/action4.action" method="post">
    用户名:<input type="text" name="username"><br/>
    年龄:<input type="text" name="age"><br/>
    <input type="submit" value="提交">
</form>
```
## 类型转换器
```
类型转换器使用步骤
	  |
	  |--编写一个类实现strutsTypeConverter
	  |
	  |--实现接口抽象方法
	  |
	  |--申明类型转换器
	  |		 |
	  |		 |--局部类型转换
	  |		 |		|
	  |		 |		|--局部类型转换器的格式,文件名为:类名-conversion.properties
	  |		 |		|
	  |		 |		|--局部类型转换器的声明，声明方式是以使用的属性名称作为Key，以类型转换器的全类名作为value
	  |		 |
	  |		 |
	  |		 |--全局类型转换
	  |		 		|
	  |		 		|--全局类型转换器文件名的命名规范 xwork-conversion.properites.文件放到路径的根路径
	  |		 		|
	  |		 		|--全局类型转换器声明，声明方式以使用数据类型为key,以类型转换器全类名为value
	  |
	  |
	  |--转换失败异常处理
	  		  |
	  		  |--action里面添加<result name="input"></result>
```
###### 类型转换器示例
```
//MyTypeConveter
public class MyTypeConverter extends StrutsTypeConverter {
    private DateFormat format=new SimpleDateFormat("MM/dd/yyyy");
    /**
     * 把字符串转换成日期
     * @param map context OGNL的上下对象，展示不用
     * @param strings 要转换的数据
     * @param aClass 目标类型
     * @return
     */
    @Override
    public Object convertFromString(Map map, String[] strings, Class aClass) {
        if(strings!=null&&strings.length>0){
            if(aClass == java.util.Date.class){
                String str = strings[0];
                try {
                    return format.parse(str);
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
    //把日期转化成字符串
    @Override
    public String convertToString(Map map, Object o) {
            if(o instanceof Date){
                format.format((Date)o);
            }
        return null;
    }
}


//com.itheima.domain.User
public class User implements Serializable{
    private String username;
    private String password;
    private Date birthday;
    private String hobby;
    private boolean married;
//get set方法...
}

//com/ithei/domain/User-conversion.properties
#局部类型转换器的格式,文件名为类名-conversion.properties
#局部类型转换器的声明，声明方式是以使用的属性名称作为Key，以类型转换器的全类名作为value
birthday=com.itheima.web.converter.MyTypeConverter

//src/xwork-conversion.properties
#全局类型转换器文件名的命名规范 xwork-conversion.properites.文件放到路径的根路径
#全局类型转换器声明，声明方式以使用数据类型为key,以类型转换器全类名为value
java.util.Date=com.itheima.web.converter.MyTypeConverter
```

## struts2的表单标签使用
```
//导入
<%@ taglib uri="/struts-tags" prefix="s" %>
<s:head></s:head><!--错误信息会变红，数据回现-->
<s:fielderror/><!--字段错误-->
<s:actionerror/><!--动作错误-->
<%--struts2的from标签，它提供了和原始html表单标签几乎一致的属性
    action:请求的地址，直接写动作名称，不用写contextpath
    method:请求方式，在这里不用写。默认post
    enctype:表单编码的MIME类型
--%>
<s:form action="register.action">
    <!--是否是必要字段(页面有*)/*的位置-->
    <s:textfield name="username" label="用户名" requiredLabel="true" requiredPosition="left"/>
    <!--showpassword 密码是否回现-->
           <s:password name="password" label="密码" showPassword="true"/>
    <s:textfield name="birthday" label="生日"/>
    <s:submit value="注册"/>
</s:form>

//user.properties
#错误提示信息 文件上在类的目录里面 命名:类名.properties
#格式invalid.fieldvalue.属性名=错误信息
invalid.fieldvalue.birthday=\u8bf7\u8f93\u5165\u6b63\u786e\u7684\u751f\u65e5\u683c\u5f0f:yyyy-MM-dd
```
## 数据验证和编程式验证
```
编程式验证
	|
	|--动作必须继承ActionSupport
	|
	|--解决验证所有的动作
	|		|
	|		|--第一种方式 不需要验证的动作添加@SkipValidation注解
	|		|				|
	|		|				|
	|    	|				|--	重写validate()方法（会在动作方法执行之前进行验证）
	|		|							|
	|		|							|--struts提供中了一个Map<表单的字段名,错误提示>
	|		|		 							 |
	|		|		  							 |--往map里面添加错误提示
	|		|		  							 |
	|		|		  			                 |--addFieldError(fieldName,errorMessage);
	|		|
	|		|
	|		|--第二种方式 定义验证方法的名称 validate+动作名称(首字母大写)		
```
```
public class UserAction extends ActionSupport implements ModelDriven<User> {
    private User user=new User();
    @Override
    public User getModel() {
        return user;
    }
    public String register(){
        IUserService us=new UserServiceImpl();
        User u = us.findUserByUsername(user.getUsername());
        if(u!=null){
            return "exists";
        }
        int result = us.register(user);
        if(result>0){
            return SUCCESS;
        }else {
            return NONE;
        }
    }
    @SkipValidation
    public String findAll(){
        return SUCCESS;
    }
    //重写了validate方法，会对这个类所有的方法验证
    //解决验证所有方法的问题
    //第一种方式 @SkipValidation
    //第二种方式 定义验证方法的名称 validate+动作名称(首字母大写)
    @Override
    public void validate() {
        if(StringUtils.isEmpty(user.getUsername())){
            addFieldError("username","用户名不能为空");
        }
    }
    //第二种方式
    public void validateRegister(){
        if(StringUtils.isEmpty(user.getUsername())){
            addFieldError("username","用户名不能为空");
        }
    }


}
```

## 声明式验证器基于字段的验证
> 通过编写验证规则的xml文件,需要验证时，编写xml。不要验证，就不写
> 所有动作验证:在动作所在的包中，建立一个ActionClassName-validation.xml的文件
> 指定动作验证:在动作所在的包中,简历一个ActionClassName-动作名称-validation.xml
> struts2提供的验证器在xwork-core-xxx.jar 根包/validator/validatos/default.xml
```
//UserAction-validation.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator 1.0.3//EN"
        "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validators>
    <!--基于字段的声明式验证-->
    <field name="user.username">
        <!--struts2框架为我们继承了很多内置的验证器,requirestring验证是否为空,并去除左右空格-->
        <field-validator type="requiredstring">
            <message>用户名必须存在</message>
        </field-validator>
    </field>
</validators>

//UserAction-register-validation.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator 1.0.3//EN"
        "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validators>
    <field name="user.username">
        <field-validator type="requiredstring">
            <message>局部验证用户名不能为空</message>
        </field-validator>
    </field>
    <!--基于验证器的验证-->
    <validator type="requiredstring">
        <!--以注入的方式提供要验证的信息-->
        <param name="fieldName">password</param>
        <message>密码必须输入</message>
    </validator>
</validators>
```

```
//StudentAction
public class StudentAction extends ActionSupport implements ModelDriven<Student> {
    private Student student=new Student();

    @Override
    public Student getModel() {
        return student;
    }
    public String addStudent(){
        return SUCCESS;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }
}

//StudentAction-addStudent-validation.xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator 1.0.3//EN"
        "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd">
<validators>
    <field name="student.username">
        <field-validator type="requiredstring">
            <message>请输入用户名</message>
        </field-validator>
    </field>
    <field name="student.age">
        <field-validator type="int">
            <!--使用注入的方式，设置最大值和最小值-->
            <param name="min">18</param>
            <param name="max">100</param>
            <message>请输入18-100之间的整数</message>
        </field-validator>
    </field>
    <field name="student.email">
        <field-validator type="email">
            <message>请输入正确的邮箱格式</message>
        </field-validator>
    </field>
    <field name="student.password">
        <field-validator type="requiredstring">
            <param name="trim">false</param>
            <message>请输入密码</message>
        </field-validator>
        <field-validator type="stringlength">
            <param name="minLength">3</param>
            <param name="maxLength">8</param>
            <message>密码长度3-8位</message>
        </field-validator>
    </field>
    <!--确认密码和密码必须一致，所以要使用基于验证器的验证-->
    <validator type="expression">
        <param name="expression">
            <![CDATA[
            password==repassword
            ]]>
        </param>
        <message>两次密码必须一致</message>
    </validator>
    <field name="student.score">
        <field-validator type="regex">
            <param name="regex">
                \d+
            </param>
            <message>请输入正确的成绩</message>
        </field-validator>
    </field>
    <field name="student.url">
        <field-validator type="url">
            <message>请输入正确的url</message>
        </field-validator>
    </field>
    <field name="student.gender">
        <!--必须不去空格-->
        <field-validator type="required">
            <message>请选择性别</message>
        </field-validator>
    </field>
</validators>
```

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
        <title>zhxiaol</title>
        <description>zhxiaol - zhxiaol</description>
        <link></link>
        <atom:link href="" rel="self" type="application/rss+xml" />
        <lastBuildDate>Thu, 01 Dec 2016 23:55:01 +0800</lastBuildDate>
        <pubDate>Thu, 01 Dec 2016 23:55:01 +0800</pubDate>
        <ttl>60</ttl>


        <item>
                <title>String类</title>
                <description>&lt;h2 id=&quot;主题介绍&quot;&gt;主题介绍&lt;/h2&gt;

&lt;p&gt;String 类有final修饰，不能被继承，不能被改变。使用++进行字符串串联底层会创建一个StringBuild或则StringBuffer,通过append()方法串联，最后在通过toString转换成String类&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;String s1=&quot;abc&quot;
String s2=s1+&quot;d&quot;;
1.会在常量池创建&quot;abc&quot;类
2.在堆内存创建StringBuild类或StringBuffer类
3.通过toString 在堆内存创建新的类
低效且消耗内存
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- more --&gt;

&lt;h2 id=&quot;常量池优先&quot;&gt;常量池优先&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;String s1=&quot;abc&quot;;
String s2=&quot;ab&quot;+&quot;c&quot;;
s1==s2(true)
常量会在编译的时候就计算出来，如果常量池有这个对象就不会创建，所以s1==s2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;new-string-quot-abc-quot&quot;&gt;new String(&amp;quot;abc&amp;quot;)&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;String s1=&quot;abc&quot;;
String s2=new String(&quot;abc&quot;)
s1==s2(flase)
&quot;abc&quot;在常量池创建对象，s2:&quot;abc&quot;因为常量池中有不会创建，s2:new String(&quot;abc&quot;)会在堆内存中创建对象，并保存一份&quot;abc&quot;的副本
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>/java/2016/12/01/String%E7%B1%BB</link>
                <guid>/java/2016/12/01/String类</guid>
                <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Object类和Class类</title>
                <description>&lt;h2 id=&quot;主题介绍&quot;&gt;主题介绍&lt;/h2&gt;

&lt;p&gt;Object类是所有类的祖宗(直接父类或者间接父类)&lt;br&gt;
Class类是对象的字节码文件，Class类的父类也是Object&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;hashcode&quot;&gt;hashCode()&lt;/h2&gt;

&lt;p&gt;返回该对象的哈希码值，该方法会根据对象地址来计算&lt;br&gt;
不同对象的hashCode()一般来说不会相同（亲测String类不同对象hashCode竟然有可能相同,尼玛太神奇了 new String(&amp;quot;abc&amp;quot;)堆内存中的对象和常量池&amp;quot;abc&amp;quot;对象hashCode()相同）。&lt;br&gt;
同一个对象的hashCode肯定相同&lt;/p&gt;

&lt;h2 id=&quot;getclass&quot;&gt;getClass()&lt;/h2&gt;

&lt;p&gt;返回对象运行时类，可以通过Class类中的getName()方法获取对象的真实类全名称&lt;/p&gt;

&lt;h2 id=&quot;tostring&quot;&gt;toString()&lt;/h2&gt;

&lt;p&gt;return getClass().getName()+&amp;quot;@&amp;quot;+Integer.toHexString(hashCode()); return com.zhxiaol.Person@673a3322&lt;/p&gt;
</description>
                <link>/java/2016/12/01/Object%E5%92%8CClass%E7%B1%BB</link>
                <guid>/java/2016/12/01/Object和Class类</guid>
                <pubDate>Thu, 01 Dec 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>Java基础复习</title>
                <description>&lt;h2 id=&quot;主题介绍&quot;&gt;主题介绍&lt;/h2&gt;

&lt;p&gt;Java基础看了有10多天了，虽然很简单，还是收获了不少东西，总结几个个人认为重要的知识点&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;源码反码补码&quot;&gt;源码反码补码&lt;/h2&gt;

&lt;p&gt;原码，就是二进制定点表示法&lt;br&gt;
反码，正数的反码是其本身，负数的反码是符号位不变，对源码逐位取反&lt;br&gt;
补码，计算机中的二进制数都是以补码的形式存储的，正数的补码是其本身，负数的补码起反码末位+1.&lt;/p&gt;

&lt;h2 id=&quot;控制跳转语句标号&quot;&gt;控制跳转语句标号&lt;/h2&gt;

&lt;p&gt;标号:标记某个循环对其控制的合法标识&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt; outer:while(true){//outer 标号
  inner:for(;;){
    if(1==2){
      continue outer;
    }else if(1==3){
      break outer;
    }else if(1==4){
      break;
    }else{
      return;
    }
  }
}  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;方法区-常量池-栈-堆&quot;&gt;方法区 常量池 栈 堆&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;class Demo{
public void static void main(String[] args){
  Person p=new Person();
  p.print();
}
}
class Person{
  public void print(){
    int a=20;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.Demo.class的文件加载到方法区（1.2如果该类有静态属性，会在静态区（方法区开辟的内存空间）初始化变量&lt;br&gt;
1.3如果该类有静态常量，常量会存储在常量池（常量池在方法区之中））&lt;br&gt;
2.main 方法进栈，Person.class进方法区（执行1.2，1.3）&lt;br&gt;
3.在堆中开辟空间创建Person,初始化代码块，成员变量，把地址赋值给p,&lt;br&gt;
4.print方法进栈 局部变量赋值 print方法出栈（成员变量属于对象 存放在堆内存 随着对象消失而消失，局部变量属于方法，存放在栈内存，随着方法结束而消失）&lt;br&gt;
5.（静态代码块会优先 代码块 成员属性初始化 构造方法 父类。。。。）只是记录要写的内容 未完待续。&lt;/p&gt;
</description>
                <link>/java/2016/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0</link>
                <guid>/java/2016/11/27/Java基础复习</guid>
                <pubDate>Sun, 27 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>音标学习</title>
                <description>&lt;p&gt;æ的发音好难啊，感觉有时候像e，有时候像∧.&lt;/p&gt;
</description>
                <link>/english/2016/11/26/%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0</link>
                <guid>/english/2016/11/26/音标学习</guid>
                <pubDate>Sat, 26 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>编译运行java文件</title>
                <description>&lt;p&gt;编译demo.java成demo.class文件&lt;/p&gt;

&lt;pre&gt;

  javac -d . xx.java  

  .代表本地目录

&lt;/pre&gt;

&lt;p&gt;运行demo.class&lt;/p&gt;

&lt;pre&gt;

java 包名.demo

&lt;/pre&gt;
</description>
                <link>/java/2016/11/26/%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cjava%E6%96%87%E4%BB%B6</link>
                <guid>/java/2016/11/26/编译运行java文件</guid>
                <pubDate>Sat, 26 Nov 2016 00:00:00 +0800</pubDate>
        </item>

        <item>
                <title>如何在Mac下安装jekyll</title>
                <description>&lt;h2 id=&quot;主题介绍&quot;&gt;主题介绍&lt;/h2&gt;

&lt;p&gt;好坑，只是想搭建个简单的blog用来记录学习，没想到填了一天的坑。技术真的就像婚前和婚后，回头再看，其实也没啥。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;配置指南&quot;&gt;配置指南&lt;/h2&gt;

&lt;h3 id=&quot;更新gem&quot;&gt;更新gem&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo gem update --system
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;安装jekyll&quot;&gt;安装jekyll&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;sudo gem install jekyll

安装成功后，查看版本
jekyll -v

遇到的坑，如果安装失败 可以尝试安装到 /usr/local/bin/目录下
sudo gem install -n /usr/local/bin/ jekyll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用jekyll&quot;&gt;使用jekyll&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;生成博客
jekyll build

开启本地预览
jekyll server

这块遇到的坑最深，差点没爬出来
如果是缺少依赖直接
sudo gem install xxx

装不上就
sudo gem install -n /usr/local/bin/ xxx

要求装固定如1.1.0版本就
sudo gem install -v 1.1.0 xxx

最后要是有多个版本的依赖 可以选择删除一个 或者用
bundle exec jekyll build
bundle exec jekyll server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                <link>/life/2016/11/26/%E5%AE%89%E8%A3%85jekyll-life</link>
                <guid>/life/2016/11/26/安装jekyll-life</guid>
                <pubDate>Sat, 26 Nov 2016 00:00:00 +0800</pubDate>
        </item>


</channel>
</rss>
